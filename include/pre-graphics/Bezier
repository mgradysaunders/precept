/*-*- C++ -*-*/
/* Copyright (c) 2018-21 M. Grady Saunders
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *   1. Redistributions of source code must retain the above
 *      copyright notice, this list of conditions and the following
 *      disclaimer.
 *
 *   2. Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following
 *      disclaimer in the documentation and/or other materials
 *      provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/*-*-*-*-*-*-*/
#if !(__cplusplus >= 201709L)
#error "Precept requires >= C++20"
#endif // #if !(__cplusplus >= 201709L)
#pragma once
#ifndef PRE_GRAPHICS_BEZIER
#define PRE_GRAPHICS_BEZIER

#include <pre-graphics/BoundBox>

namespace pre {

/// A bezier curve segment.
///
/// \tparam Float  Float type.
/// \tparam N      Point dimension.
/// \tparam D      Degree.
///
template <std::floating_point Float, size_t N, size_t D>
struct Bezier : ArrayLike<Bezier<Float, N, D>, Array<Float, N>> {
  public:
    using Point = Array<Float, N>;

    constexpr Bezier() noexcept = default;

    template <typename... Points>
    constexpr Bezier(const Point& p0, const Points&... pk) noexcept
        : points{p0, pk...} {
        static_assert(sizeof...(Points) + 1 == D + 1);
    }

    template <std::floating_point Other>
    explicit constexpr Bezier(const Array<Other, N>* ps) noexcept {
        std::copy(ps, ps + D + 1, begin());
    }

  public:
    /// \name Container API
    /** \{ */

    constexpr size_t size() const noexcept {
        return D + 1;
    }

    constexpr Point* begin() noexcept {
        return &points[0];
    }

    constexpr const Point* begin() const noexcept {
        return &points[0];
    }

    constexpr Point* end() noexcept {
        return &points[0] + size();
    }

    constexpr const Point* end() const noexcept {
        return &points[0] + size();
    }

    /** \} */

  public:
    /// Value operator.
    constexpr Point operator()(Float t) const noexcept {
        if constexpr (D == 0) {
            return points[0];
        }
        else if constexpr (D == 1) {
            return lerp(t, points[0], points[1]);
        }
        else if constexpr (D == 2) {
            Float u = 1 - t;
            Float u2 = u * u;
            Float t2 = t * t;
            return u2 * points[0] + (2 * u * t) * points[1] + t2 * points[2];
        }
        else if constexpr (D == 3) {
            Float u = 1 - t;
            Float u2 = u * u, u3 = u * u2;
            Float t2 = t * t, t3 = t * t2;
            return u3 * points[0] + (3 * u2 * t) * points[1] +
                   (3 * u * t2) * points[2] + t3 * points[3];
        }
        else {
            return lerp(
                    t, //
                    Bezier<Float, N, D - 1>(&points[0])(t),
                    Bezier<Float, N, D - 1>(&points[1])(t));
        }
    }

    /// Derivative.
    constexpr Bezier<Float, N, D - 1> deriv() const noexcept requires(D > 0) {
        Bezier<Float, N, D - 1> bez;
        for (size_t k = 0; k < D; k++)
            bez.points[k] = D * (points[k + 1] - points[k]);
        return bez;
    }

    /// Nth derivative.
    template <size_t Which = D>
    constexpr Bezier<Float, N, D - Which> nth_deriv() const noexcept {
        if constexpr (Which == 0)
            return *this;
        else
            return nth_deriv<Which - 1>().deriv();
    }

    /// Increase the degree of the curve.
    [[nodiscard]] constexpr Bezier<Float, N, D + 1> increase_degree()
            const noexcept requires(D > 0) {
        if constexpr (D == 1) {
            return Bezier<Float, N, 2>{
                    points[0], Float(0.5) * (points[0] + points[1]),
                    points[1]};
        }
        else {
            Bezier<Float, N, D + 1> bez;
            bez.points[0] = points[0];
            bez.points[D + 1] = points[D];
            for (size_t k = 1; k < D + 1; k++)
                bez.points[k] = (Float(k) / Float(D + 1)) * points[k - 1] +
                                (Float(D + 1 - k) / Float(D + 1)) * points[k];
            return bez;
        }
    }

    /// Decrease the degree of the curve.
    [[nodiscard]] constexpr Bezier<Float, N, D - 1> decrease_degree()
            const noexcept requires(D > 1) {
        if constexpr (D == 2) {
            return Bezier<Float, N, 1>{points[0], points[2]};
        }
        else {
            // Just in case it isn't ideally reducible, average the
            // forward and reverse formulations.
            Bezier<Float, N, D - 1> fwd, rev;
            fwd.points[0] = points[0];
            rev.points[0] = points[0];
            fwd.points[D - 1] = points[D];
            rev.points[D - 1] = points[D];
            for (size_t k = 1, l = D - 2; k < D - 1; k++, l--) {
                fwd.points[k] = (Float(D) / Float(D - k)) * points[k] -
                                (Float(k) / Float(D - k)) * fwd.points[k - 1];
                rev.points[l] =
                        (Float(D) / Float(l + 1)) * points[l + 1] -
                        (Float(D) / Float(l + 1) - 1) * rev.points[l + 1];
            }
            for (size_t k = 1; k < D - 1; k++) {
                fwd.points[k] *= Float(0.5);
                fwd.points[k] += Float(0.5) * rev.points[k];
            }
            return fwd;
        }
    }

    /// Reverse.
    [[nodiscard]] constexpr Bezier<Float, N, D> reverse() const noexcept {
        Bezier<Float, N, D> bez = *this;
        std::reverse(bez.begin(), bez.end());
        return bez;
    }

    /// Length.
    Float length() const noexcept requires(D <= 3) {
        if constexpr (std::same_as<Float, float>) {
            return Bezier<double, N, D>(*this).length();
        }
        else if constexpr (D == 0) {
            return 0;
        }
        else if constexpr (D == 1) {
            return pre::length(points[1] - points[0]);
        }
        else if constexpr (D == 2) {
            Point q0 = 2 * (points[0] - 2 * points[1] + points[2]);
            Point q1 = 2 * (points[1] - points[0]);
            Float a = dot(q0, q0), b = 2 * dot(q0, q1);
            Float c = dot(q1, q1);
            Float a1_2 = pre::sqrt(a);
            Float c1_2 = pre::sqrt(c);
            Float s1_2 = pre::sqrt(a + b + c);
            Float len = s1_2 / 2 + b * (s1_2 - c1_2) / (4 * a);
            if (Float d = (b * b - 4 * a * c) / (8 * a1_2 * a);
                pre::isfinite(d) && d != 0) {
                Float numer = b + 2 * (a + a1_2 * s1_2);
                Float denom = b + 2 * a1_2 * c1_2;
                Float log_term = -d * pre::log(numer / denom);
                if (pre::isfinite(log_term))
                    len += log_term;
            }
            return len;
        }
        else {
            StaticStack<Bezier, 16> todo;
            todo.push(*this);
            Float len = 0;
            while (not todo.empty()) {
                Bezier curr = todo.pop();
                // Is approximately quadratic?
                Float tmp0 = length2(curr.nth_deriv()[0]);
                Float tmp1 = std::max(
                        length2(curr[3] - curr[0]),
                        length2(curr.decrease_degree().nth_deriv()[0]));
                if (todo.size() > 14 or //
                    tmp0 <= tmp1 * Float(0.001)) {
                    len += curr.decrease_degree().length();
                }
                else {
                    auto [next0, next1] = curr.cut(0.5);
                    todo.push(next0);
                    todo.push(next1);
                }
            }
            return len;
        }
    }

    /// Subset on range \f$ [0, t] \f$.
    constexpr Bezier subset(Float t) const noexcept {
        if constexpr (D == 0) {
            return *this;
        }
        else if constexpr (D == 1) {
            return {points[0], lerp(t, points[0], points[1])};
        }
        else if constexpr (D == 2) {
            Point tmp0 = lerp(t, points[0], points[1]);
            Point tmp1 = lerp(t, points[1], points[2]);
            return {points[0], tmp0, lerp(t, tmp0, tmp1)};
        }
        else {
            Bezier bez;
            bez.points[0] = points[0];
            Point tmps[2 * (D + 1)];
            Point* tmps0 = &tmps[0];
            Point* tmps1 = &tmps[D + 1];
            for (size_t k = 0; k < D + 1; k++)
                tmps0[k] = points[k];
            for (size_t j = 1; j < D + 1; j++) {
                for (size_t k = 0; k < D + 1 - j; k++)
                    tmps1[k] = lerp(t, tmps0[k], tmps0[k + 1]);
                bez.points[j] = tmps1[0];
                std::swap(tmps0, tmps1);
            }
            return bez;
        }
    }

    /// Subset on range \f$ [t_0, t_1] \f$.
    constexpr Bezier subset(Float t0, Float t1) const noexcept {
        if (t1 < t0)
            return subset(t1, t0).reverse();
        else
            return subset(t1).reverse().subset(1 - t0 * t1).reverse();
    }

    constexpr std::pair<Bezier, Bezier> cut(Float t) const noexcept {
        return {subset(t), reverse().subset(1 - t).reverse()};
    }

    template <std::floating_point Other>
    constexpr operator Bezier<Other, N, D>() const noexcept {
        return Bezier<Other, N, D>(&points[0]);
    }

  public:
    Point points[D + 1];
};

template <typename T, size_t N, concepts::array... Args>
Bezier(const Array<T, N>&, const Args&...)
        -> Bezier<to_floating_point_t<T>, N, sizeof...(Args)>;

template <std::floating_point Float = float>
using QuadraticBezier2 = Bezier<Float, 2, 2>;

template <std::floating_point Float = float>
using QuadraticBezier3 = Bezier<Float, 3, 2>;

template <std::floating_point Float = float>
using CubicBezier2 = Bezier<Float, 2, 3>;

template <std::floating_point Float = float>
using CubicBezier3 = Bezier<Float, 3, 3>;

} // namespace pre

#endif // #ifndef PRE_GRAPHICS_BEZIER
