/*-*- C++ -*-*/
/* Copyright (c) 2018-21 M. Grady Saunders
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 
 *   1. Redistributions of source code must retain the above
 *      copyright notice, this list of conditions and the following
 *      disclaimer.
 * 
 *   2. Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following
 *      disclaimer in the documentation and/or other materials
 *      provided with the distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/*-*-*-*-*-*-*/
#if !(__cplusplus >= 201709L)
#error "Precept requires >= C++20"
#endif // #if !(__cplusplus >= 201709L)
#pragma once
#ifndef PRE_GRAPHICS_DBVH
#define PRE_GRAPHICS_DBVH

#include <pre/memory>
#include <pre-graphics/BoundBox>

namespace pre {

/// A dynamic bounding volume hierarchy.
///
/// \note
/// This is based on the dynamic tree implementation in Box2D, which
/// is in turn based on the dynamic tree implementation in Bullet3D.
///
template <size_t Dim>
class Dbvh {
  public:
    using Box = BoundBox<float, Dim>;

    using Index = std::int32_t;

    static constexpr Index Nil = -1;

    struct Node {
        Box box;
        union {
            Index parent;
            Index next;
        };
        Index child0 = Nil;
        Index child1 = Nil;
        Index height = 0;

        constexpr bool is_leaf() const noexcept {
            return child0 == Nil;
        }
        constexpr bool is_branch() const noexcept {
            return child0 != Nil;
        }
    };

  public:
    Dbvh() = default;

    Dbvh(const Dbvh&) = default;

    Dbvh(Dbvh&&) = default;

    Dbvh& operator=(const Dbvh&) = default;

    Dbvh& operator=(Dbvh&&) = default;

  public:
    Index max_height() const;

    Index max_imbalance() const;

    Index insert(const Box& box);

    void remove(Index node);

    void clear() noexcept {
        nodes_.clear();
        free_ = Nil;
        root_ = Nil;
    }

    bool empty() const noexcept {
        return root_ == Nil;
    }

    void rebuild_optimal();

    Node& operator[](Index node) noexcept {
        return nodes_[node];
    }

    const Node& operator[](Index node) const noexcept {
        return nodes_[node];
    }

  private:
    std::vector<Node> nodes_;

    Index free_ = Nil;

    Index root_ = Nil;

  private:
    /// \name Private implementation
    /** \{ */

    Index private_allocate();

    void private_deallocate(Index node);

    void private_insert(Index node);

    void private_remove(Index node);

    Index private_balance(Index node);

    template <bool IsDynamic, typename Func>
    void private_traverse(const Box& box, Func&& func);

    /** \} */
};

template <size_t Dim>
inline typename Dbvh<Dim>::Index Dbvh<Dim>::max_height() const {
    return root_ == Nil ? 0 : nodes_[root_].height;
}

template <size_t Dim>
inline typename Dbvh<Dim>::Index Dbvh<Dim>::max_imbalance() const {
    Index imbalance = 0;
    for (const Node& node_ref : nodes_) {
        if (node_ref.height < 2)
            continue;
        const Node& child0_ref = nodes_[node_ref.child0];
        const Node& child1_ref = nodes_[node_ref.child1];
        imbalance = pre::max(
                imbalance, pre::abs(child0_ref.height - child1_ref.height));
    }
    return imbalance;
}

template <size_t Dim>
inline typename Dbvh<Dim>::Index Dbvh<Dim>::insert(const Box& box) {
    Index node = private_allocate();
    Node& node_ref = nodes_[node];
    node_ref.box = box;
    node_ref.height = 0;
    private_insert(node);
    return node;
}

template <size_t Dim>
inline void Dbvh<Dim>::remove(Index node) {
    private_remove(node);
    private_deallocate(node);
}

template <size_t Dim>
inline void Dbvh<Dim>::rebuild_optimal() {
    if (root_ == Nil)
        return;
    std::vector<Index> todo;
    todo.reserve(nodes_.size());
    for (Index node = 0; node < Index(nodes_.size()); node++) {
        if (nodes_[node].height < 0)
            continue;
        if (nodes_[node].is_leaf()) {
            nodes_[node].parent = Nil;
            todo.push_back(node);
        }
        else {
            private_deallocate(node);
        }
    }
    while (todo.size() > 1) {
        float min_cost = INFINITY;
        Index mini = -1;
        Index minj = -1;
        for (Index i = 0; i < Index(todo.size()); ++i) {
            for (Index j = i + 1; j < Index(todo.size()); ++j) {
                Box boxi = nodes_[todo[i]].box;
                Box boxj = nodes_[todo[j]].box;
                float cost = (boxi | boxj).surface_area();
                if (min_cost > cost)
                    min_cost = cost, mini = i, minj = j;
            }
        }
        Index parent = private_allocate();
        Index child0 = todo[mini];
        Index child1 = todo[minj];
        Node& child0_ref = nodes_[child0];
        Node& child1_ref = nodes_[child1];
        Node& parent_ref = nodes_[parent];
        parent_ref.child0 = child0;
        parent_ref.child1 = child1;
        parent_ref.height = pre::max(child0_ref.height, child1_ref.height);
        parent_ref.height++;
        parent_ref.box = child0_ref.box | child1_ref.box;
        parent_ref.parent = Nil;
        child0_ref.parent = parent;
        child1_ref.parent = parent;
        todo[minj] = todo.back();
        todo[mini] = parent;
        todo.pop_back();
    }
    root_ = todo[0];
}

template <size_t Dim>
inline typename Dbvh<Dim>::Index Dbvh<Dim>::private_allocate() {
    if (free_ == Nil) {
        Index nodes_size = nodes_.size();
        if (nodes_.size() == 0)
            nodes_.resize(32);
        else
            nodes_.resize(nodes_.size() * 2);
        for (Index node = nodes_size; node < Index(nodes_.size()); node++) {
            nodes_[node].next = node + 1;
            nodes_[node].height = -1;
        }
        nodes_.back().next = Nil;
        free_ = nodes_size;
    }
    Index node = free_;
    free_ = nodes_[node].next;
    nodes_[node] = Node();
    return node;
}

template <size_t Dim>
inline void Dbvh<Dim>::private_deallocate(Index node) {
    nodes_[node].next = free_;
    nodes_[node].height = -1;
    free_ = node;
}

template <size_t Dim>
inline void Dbvh<Dim>::private_insert(Index leaf) {
    if (root_ == Nil) {
        root_ = leaf;
        nodes_[root_].parent = Nil;
        return;
    }
    Box leaf_box = nodes_[leaf].box;
    Index node = root_;
    while (nodes_[node].is_branch()) {
        Node& node_ref = nodes_[node];
        Node& child0_ref = nodes_[node_ref.child0];
        Node& child1_ref = nodes_[node_ref.child1];
        float area = node_ref.box.surface_area();
        float combined_area = (leaf_box | node_ref.box).surface_area();
        float cost = 2 * combined_area;
        float cost_child0 = 2 * (combined_area - area);
        float cost_child1 = 2 * (combined_area - area);
        cost_child0 += (leaf_box | child0_ref.box).surface_area();
        cost_child1 += (leaf_box | child1_ref.box).surface_area();
        if (child0_ref.is_branch())
            cost_child0 -= child0_ref.box.surface_area();
        if (child1_ref.is_branch())
            cost_child1 -= child1_ref.box.surface_area();
        if (cost < cost_child0 and //
            cost < cost_child1)
            break;
        else
            node = cost_child0 < cost_child1 ? node_ref.child0
                                             : node_ref.child1;
    }
    Index old_parent = nodes_[node].parent;
    Index new_parent = private_allocate();
    Node& new_parent_ref = nodes_[new_parent];
    new_parent_ref.parent = old_parent;
    new_parent_ref.box = leaf_box | nodes_[node].box;
    new_parent_ref.child0 = node;
    new_parent_ref.child1 = leaf;
    new_parent_ref.height = nodes_[node].height + 1;
    nodes_[node].parent = new_parent;
    nodes_[leaf].parent = new_parent;
    if (old_parent != Nil) {
        if (nodes_[old_parent].child0 == node)
            nodes_[old_parent].child0 = new_parent;
        else
            nodes_[old_parent].child1 = new_parent;
    }
    else
        root_ = new_parent; // Sibling was root

    node = nodes_[leaf].parent;
    while (node != Nil) {
        node = private_balance(node);
        Node& node_ref = nodes_[node];
        Node& child0_ref = nodes_[node_ref.child0];
        Node& child1_ref = nodes_[node_ref.child1];
        node_ref.height = 1 + pre::max(child0_ref.height, child1_ref.height);
        node_ref.box = child0_ref.box | child1_ref.box;
        node = node_ref.parent;
    }
}

template <size_t Dim>
inline void Dbvh<Dim>::private_remove(Index leaf) {
    if (root_ == leaf) {
        root_ = Nil;
        return;
    }
    Index parent = nodes_[leaf].parent;
    Index sibling = nodes_[parent].child0 == leaf ? nodes_[parent].child1
                                                  : nodes_[parent].child0;
    if (Index grandparent = nodes_[parent].parent; grandparent != Nil) {
        if (nodes_[grandparent].child0 == parent)
            nodes_[grandparent].child0 = sibling;
        else
            nodes_[grandparent].child1 = sibling;
        nodes_[sibling].parent = grandparent;
        private_deallocate(parent);

        Index node = grandparent;
        while (node != Nil) {
            node = private_balance(node);
            Node& node_ref = nodes_[node];
            Node& child0_ref = nodes_[node_ref.child0];
            Node& child1_ref = nodes_[node_ref.child1];
            node_ref.box = child0_ref.box | child1_ref.box;
            node_ref.height = pre::max(child0_ref.height, child1_ref.height);
            node_ref.height++;
            node = node_ref.parent;
        }
    }
    else {
        root_ = sibling;
        nodes_[sibling].parent = Nil;
        private_deallocate(parent);
    }
}

template <size_t Dim>
inline typename Dbvh<Dim>::Index Dbvh<Dim>::private_balance(Index a) {
    Node& a_ref = nodes_[a];
    if (a_ref.is_leaf() or a_ref.height < 2)
        return a;
    Index b = a_ref.child0;
    Index c = a_ref.child1;
    Node& b_ref = nodes_[b];
    Node& c_ref = nodes_[c];
    Index imbalance = c_ref.height - b_ref.height;
    // Rotate C up to A.
    if (imbalance > 1) {
        Index f = c_ref.child0;
        Index g = c_ref.child1;
        Node& f_ref = nodes_[f];
        Node& g_ref = nodes_[g];
        // Swap A and C.
        c_ref.child0 = a;
        c_ref.parent = a_ref.parent;
        a_ref.parent = c;
        if (c_ref.parent != Nil) {
            if (nodes_[c_ref.parent].child0 == a)
                nodes_[c_ref.parent].child0 = c;
            else
                nodes_[c_ref.parent].child1 = c;
        }
        else
            root_ = c;
        // Rotate.
        if (f_ref.height > g_ref.height) {
            c_ref.child1 = f;
            a_ref.child1 = g;
            g_ref.parent = a;
            a_ref.box = b_ref.box | g_ref.box;
            c_ref.box = a_ref.box | f_ref.box;
            a_ref.height = 1 + pre::max(b_ref.height, g_ref.height);
            c_ref.height = 1 + pre::max(a_ref.height, f_ref.height);
        }
        else {
            c_ref.child1 = g;
            a_ref.child1 = f;
            f_ref.parent = a;
            a_ref.box = b_ref.box | f_ref.box;
            c_ref.box = a_ref.box | g_ref.box;
            a_ref.height = 1 + pre::max(b_ref.height, f_ref.height);
            c_ref.height = 1 + pre::max(a_ref.height, g_ref.height);
        }
        return c;
    }
    // Rotate B up to A.
    if (imbalance < -1) {
        Index d = b_ref.child0;
        Index e = b_ref.child1;
        Node& d_ref = nodes_[d];
        Node& e_ref = nodes_[e];
        // Swap A and B.
        b_ref.child0 = a;
        b_ref.parent = a_ref.parent;
        a_ref.parent = b;
        if (b_ref.parent != Nil) {
            if (nodes_[b_ref.parent].child0 == a)
                nodes_[b_ref.parent].child0 = b;
            else
                nodes_[b_ref.parent].child1 = b;
        }
        else
            root_ = b;
        // Rotate.
        if (d_ref.height > e_ref.height) {
            b_ref.child1 = d;
            a_ref.child0 = e;
            e_ref.parent = a;
            a_ref.box = c_ref.box | e_ref.box;
            b_ref.box = a_ref.box | d_ref.box;
            a_ref.height = 1 + pre::max(c_ref.height, e_ref.height);
            b_ref.height = 1 + pre::max(a_ref.height, d_ref.height);
        }
        else {
            b_ref.child1 = e;
            a_ref.child0 = d;
            d_ref.parent = a;
            a_ref.box = c_ref.box | d_ref.box;
            b_ref.box = a_ref.box | e_ref.box;
            a_ref.height = 1 + pre::max(c_ref.height, d_ref.height);
            b_ref.height = 1 + pre::max(a_ref.height, e_ref.height);
        }
        return b;
    }
    return a;
}

#if 0
template <size_t Dim>
template <bool IsDynamic, typename Func>
inline void Dbvh<Dim>::private_traverse(const Box& box, Func&& func) {
    StaticStack<Index, 128> todo;
    if (root_ != Nil)
        todo.push(root_);
    while (not todo.empty()) {
        Index node = todo.pop();
        Node& node_ref = nodes_[node];
        if (node_ref.is_branch()) {
            if (nodes_[node_ref.child0].box.overlaps(box))
                todo.push(node_ref.child0);
            if (nodes_[node_ref.child1].box.overlaps(box))
                todo.push(node_ref.child1);
        }
        else if (not std::invoke(func, node))
            return;
    }
}
#endif

using Dbvh2 = Dbvh<2>;

using Dbvh3 = Dbvh<3>;

} // namespace pre

#endif // #ifndef PRE_GRAPHICS_DBVH
