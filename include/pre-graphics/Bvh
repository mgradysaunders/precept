/*-*- C++ -*-*/
/* Copyright (c) 2018-21 M. Grady Saunders
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *   1. Redistributions of source code must retain the above
 *      copyright notice, this list of conditions and the following
 *      disclaimer.
 *
 *   2. Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following
 *      disclaimer in the documentation and/or other materials
 *      provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/*-*-*-*-*-*-*/
#if !(__cplusplus >= 201709L)
#error "Precept requires >= C++20"
#endif // #if !(__cplusplus >= 201709L)
#pragma once
#ifndef PRE_GRAPHICS_BVH
#define PRE_GRAPHICS_BVH

#include <pre-graphics/BoundBox>

#include "_hidden/NodeIterator.inl"

#include "_hidden/NodeStack.inl"

namespace pre {

template <
        typename Value,
        typename Alloc,
        std::floating_point Float,
        size_t Dim>
class Bvh {
    static_assert(Dim == 2 or Dim == 3);

  public:
    using Point = Array<Float, Dim>;

    using Box = BoundBox<Float, Dim>;

    using Ray = BasicRay<Float, Dim>;

    typedef size_t size_type;

    typedef std::ptrdiff_t difference_type;

    typedef Value value_type;

    typedef value_type& reference;

    typedef value_type* pointer;

    typedef const value_type& const_reference;

    typedef const value_type* const_pointer;

    struct Node {
        Node* next = nullptr;

        Node* parent = nullptr;

        Box box;

        int axis = 0;

        static constexpr int AxisLeaf = -1;

        static constexpr int AxisLeafErased = -2;

        union {
            Explicit<Value> leaf;
            struct {
                Node* left;
                Node* right;
            } branch;
        };

        constexpr bool is_leaf() const noexcept {
            return axis < 0;
        }

        constexpr bool is_branch() const noexcept {
            return not is_leaf();
        }

        constexpr void recalc_branch() noexcept {
            box = branch.left->box | branch.right->box;
            Point lcenter = branch.left->box.center();
            Point rcenter = branch.right->box.center();
            axis = pre::abs(lcenter - rcenter).argmax();
            if (lcenter[axis] > rcenter[axis])
                std::swap(branch.left, branch.right);
        }
    };

    struct NodeTraits {
        using Node = typename Bvh::Node;

        static constexpr value_type& value(Node* node) noexcept {
            return *node->leaf;
        }
        static constexpr bool has_value(Node* node) noexcept {
            return node->axis == Node::AxisLeaf;
        }
    };

    typedef tree_helpers::NodeIterator<NodeTraits, 0> iterator;

    typedef tree_helpers::NodeIterator<NodeTraits, 1> const_iterator;

    template <bool IsDynamic>
    using NodeStack = tree_helpers::NodeStack<Node, IsDynamic>;

    using NodePool = ObjectHeapPool<Node, Alloc>;

    static_assert(sizeof(Node) <= 256);

  public:
    Bvh(size_t pool_size = 32768 / sizeof(Node), const Alloc& alloc = {})
        : pool_(pool_size, alloc) {
    }

    Bvh(const Bvh&) = delete;

    Bvh(Bvh&& other)
        : pool_(std::move(other.pool_)), //
          root_(steal(other.root_)),     //
          head_(steal(other.head_)), head_branch_(steal(other.head_branch_)),
          size_(steal(other.size_)), size_erased_(steal(other.size_erased_)),
          depth_(steal(other.depth_)) {
    }

    ~Bvh() {
        clear();
    }

    Bvh& operator=(const Bvh&) = delete;

    Bvh& operator=(Bvh&& other) {
        clear();
        pool_ = std::move(other.pool_);
        root_ = steal(other.root_);
        head_ = steal(other.head_);
        head_branch_ = steal(other.head_branch_);
        size_ = steal(other.size_);
        size_erased_ = steal(other.size_erased_);
        depth_ = steal(other.depth_);
        return *this;
    }

  public:
    size_t size() const noexcept {
        return size_;
    }

    bool empty() const noexcept {
        return size_ == 0;
    }

    iterator begin() noexcept {
        return head_;
    }

    const_iterator begin() const noexcept {
        return head_;
    }

    const_iterator cbegin() const noexcept {
        return begin(); // Force const
    }

    iterator end() noexcept {
        return nullptr;
    }

    const_iterator end() const noexcept {
        return nullptr;
    }

    const_iterator cend() const noexcept {
        return end(); // Force const
    }

  public:
    iterator insert(const Box& box, const Value& value) {
        Node* node = pool_.allocate();
        node->next = nullptr;
        node->parent = nullptr;
        node->box = box;
        node->axis = Node::AxisLeaf;
        node->leaf.construct(value);
        if (root_ == nullptr)
            root_ = node;
        else
            do_insert(root_, node);
        do_prepend(head_, node);
        size_++;
        return node;
    }

    iterator erase(const_iterator pos) noexcept {
        Node* node = const_cast<Node*>(pos.node);
        ASSERT(node);
        ASSERT(node->axis == Node::AxisLeaf);
        if constexpr (!std::is_trivially_destructible_v<Value>)
            node->leaf.deconstruct();
        node->axis = Node::AxisLeafErased;
        --size_;
        ++size_erased_;
        return node->next;
    }

    const Node* root() const noexcept {
        return root_;
    }

    size_t depth() const noexcept {
        return depth_;
    }

    size_t optimal_depth() const noexcept {
        return first1(roundpow2(size_));
    }

    bool should_rebalance() const noexcept {
        return depth() > 2 * optimal_depth() || size_erased_ > size_;
    }

    void rebalance() {
        if (empty()) {
            clear();
            return;
        }
        std::vector<Node*> leaves;
        leaves.reserve(size());
        Node* next = nullptr;
        for (Node* node = head_; node; node = next) {
            next = node->next;
            if (node->axis == Node::AxisLeaf)
                leaves.push_back(node);
            else
                pool_.deallocate(node);
        }
        for (Node* node = head_branch_; node; node = next) {
            next = node->next;
            pool_.deallocate(node);
        }
        head_branch_ = nullptr;
        size_erased_ = depth_ = 0;
        root_ = do_rebalance(
                nullptr, {&leaves[0], //
                          &leaves[0] + leaves.size()});
        head_ = leaves.front();
        for (auto leaf = leaves.begin(); leaf + 1 < leaves.end(); ++leaf)
            (*leaf)->next = *(leaf + 1);
        leaves.back()->next = nullptr;
    }

    void rebalance_if_necessary() {
        if (should_rebalance())
            rebalance();
    }

    void clear() noexcept {
        if constexpr (!std::is_trivially_destructible_v<Value>)
            for (auto& value : *this)
                value.~Value();
        pool_.reset();
        root_ = head_ = head_branch_ = nullptr;
        size_ = size_erased_ = depth_ = 0;
    }

  public:
    template <std::invocable<iterator> Func>
    void traverse(const Box& box, Func&& func) const {
        if (depth_ < tree_helpers::StaticStackSize)
            do_traverse<0>(box, std::forward<Func>(func));
        else
            do_traverse<1>(box, std::forward<Func>(func));
    }

    int erase_overlaps(const Box& box) {
        int count = 0;
        traverse(box, [&](auto pos) {
            count++;
            erase(pos);
            return true; // Keep going.
        });
        return count;
    }

    int count_overlaps(const Box& box) const {
        int count = 0;
        traverse(box, [&](auto) {
            count++;
            return true; // Keep going.
        });
        return count;
    }

    template <std::invocable<iterator> Func>
    void traverse(const Ray& ray, Func&& func) const {
        if (depth_ < tree_helpers::StaticStackSize)
            do_traverse<0>(ray, std::forward<Func>(func));
        else
            do_traverse<1>(ray, std::forward<Func>(func));
    }

  private:
    NodePool pool_;

    Node* root_ = nullptr;

    Node* head_ = nullptr;

    Node* head_branch_ = nullptr;

    size_t size_ = 0;

    size_t size_erased_ = 0;

    size_t depth_ = 0;

  private:
    static void do_prepend(Node*& head, Node* node) {
        node->next = head;
        head = node;
    }

    void do_insert(Node*& node, Node* leaf, size_t depth = 0) {
        if (node->axis < 0 or not node->box.contains(leaf->box)) {
            Node* parent = node->parent;
            Node* branch = pool_.allocate();
            branch->next = nullptr;
            branch->parent = parent;
            branch->axis = 0;
            branch->branch.left = node;
            branch->branch.right = leaf;
            branch->recalc_branch();
            do_prepend(head_branch_, branch);
            node = branch;
            if (depth_ < depth)
                depth_ = depth;
        }
        else {
            Node*& child =
                    leaf->box.center(node->axis) < node->box.center(node->axis)
                            ? node->branch.left
                            : node->branch.right;
            do_insert(child, leaf, depth + 1);
            node->recalc_branch();
        }
    }

    Node* do_rebalance(
            Node* parent, IteratorRange<Node**> leaves, size_t depth = 0) {
        if (leaves.size() == 1) {
            leaves[0]->parent = parent;
            if (depth_ < depth)
                depth_ = depth;
            return leaves[0];
        }
        Node* node = pool_.allocate();
        node->next = nullptr;
        node->parent = parent;
        Box box;
        Box box_center;
        for (const Node* leaf : leaves) {
            box |= leaf->box;
            box_center |= leaf->box.center();
        }
        node->box = box;
        node->axis = box.extent().argmax();
        Node** middle = leaves.begin() + leaves.size() / 2;
        std::nth_element(
                leaves.begin(), middle, leaves.end(),
                [=](const Node* leaf0, const Node* leaf1) {
                    return leaf0->box.center(node->axis) <
                           leaf1->box.center(node->axis);
                });
        node->branch.left =
                do_rebalance(node, {leaves.begin(), middle}, depth + 1);
        node->branch.right =
                do_rebalance(node, {middle, leaves.end()}, depth + 1);
        do_prepend(head_branch_, node);
        return node;
    }

  private:
    template <bool IsDynamic, typename Func>
    void do_traverse(const Box& box, Func&& func) const {
        NodeStack<IsDynamic> todo(optimal_depth(), root_);
        while (not todo.empty()) {
            Node* node = todo.pop();
            if (node->axis >= 0) {
                Node* node0 = node->branch.left;
                Node* node1 = node->branch.right;
                todo.push_if(box.overlaps(node0->box), node0);
                todo.push_if(box.overlaps(node1->box), node1);
            }
            else if (
                    node->axis == Node::AxisLeaf and
                    not std::invoke(func, iterator(node)))
                return;
        }
    }

    template <bool IsDynamic, typename Func>
    void do_traverse(const Ray& ray, Func&& func) const {
        BoundBoxRayTester tester(ray);
        NodeStack<IsDynamic> todo(optimal_depth(), root_);
        while (not todo.empty()) {
            Node* node = todo.pop();
            if (not tester(node->box))
                continue;
            if (node->axis >= 0) {
                Node* node0 = node->branch.left;
                Node* node1 = node->branch.right;
                if (tester.dir_sgn[node->axis] == 0)
                    std::swap(node0, node1);
                todo.push(node0);
                todo.push(node1);
            }
            else if (
                    node->axis == Node::AxisLeaf and
                    not std::invoke(func, iterator(node)))
                return;
        }
    }
};

template <
        typename Value,
        typename Alloc = std::allocator<std::byte>,
        std::floating_point Float = float>
using Bvh2 = Bvh<Value, Alloc, Float, 2>;

template <
        typename Value,
        typename Alloc = std::allocator<std::byte>,
        std::floating_point Float = float>
using Bvh3 = Bvh<Value, Alloc, Float, 3>;

} // namespace pre

#endif // #ifndef PRE_GRAPHICS_BVH
