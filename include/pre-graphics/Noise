/*-*- C++ -*-*/
/* Copyright (c) 2018-21 M. Grady Saunders
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *   1. Redistributions of source code must retain the above
 *      copyright notice, this list of conditions and the following
 *      disclaimer.
 *
 *   2. Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following
 *      disclaimer in the documentation and/or other materials
 *      provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/*-*-*-*-*-*-*/
#pragma once
#ifndef PRE_GRAPHICS_SIMPLEX_NOISE
#define PRE_GRAPHICS_SIMPLEX_NOISE

#include <pre/Array>
#include <pre/random>

namespace pre {

/// A simplex noise generator.
template <std::floating_point Float, size_t Dim>
struct Noise {
    static_assert(Dim <= 16, "Probably not robust beyond 16 dimensions!");

  public:
    using Coord = Array<Float, Dim>;
    using CoordInt = Array<int, Dim>;

    constexpr Noise() noexcept = default;
    constexpr Noise(std::uint32_t seed_) noexcept : seed(seed_) {
    }

    struct Result {
        Float value = 0;  ///< Value in [-1, +1].
        Coord deriv = {}; ///< Partial derivatives.
    };

    Result operator()(const Coord& t) const noexcept;

  public:
    std::uint32_t seed = 0;
};

template <std::floating_point Float, size_t Dim>
inline typename Noise<Float, Dim>::Result Noise<Float, Dim>::operator()(
        const Coord& t) const noexcept {

    // Skew, shift into [0, 1)^2.
    static const Float f = (1.0 / Dim) * (pre::sqrt(Dim + 1) - 1);
    static const Float g = (1.0 / Dim) * (1 - 1 / pre::sqrt(Dim + 1));
    Coord tskew = t + f * t.sum();
    CoordInt tskew0 = fast_floor(tskew);
    tskew -= tskew0;

    // Determine decreasing order of coordinate values.
    CoordInt reorder = {};
    if constexpr (Dim == 2) {
        reorder = {0, 1};
        if (tskew[0] < tskew[1])
            reorder = {1, 0};
    }
    else if constexpr (Dim > 2) {
        using FloatInt = std::pair<Float, int>;
        FloatInt pairs[Dim];
        for (size_t k = 0; k < Dim; k++)
            pairs[k] = FloatInt(tskew[k], int(k));
        std::sort(
                &pairs[0],       //
                &pairs[0] + Dim, //
                [](const FloatInt& lhs, const FloatInt& rhs) {
                    return lhs.first > rhs.first;
                });
        for (size_t k = 0; k < Dim; k++)
            reorder[k] = pairs[k].second;
    }

    // Gradient calculator.
    auto gradient = [this](const CoordInt& loc) {
        int stream = loc[0];
        for (size_t k = 1; k < Dim; k++)
            stream = cantor(stream, loc[k]);
        Coord grad;
        Pcg32 gen(seed, stream);
        for (size_t k = 0; k < Dim; k++)
            grad[k] = (2 / Float(15)) * gen(16) - 1;
        return grad;
    };

    // Add terms.
    Coord ver0 = tskew0 - g * tskew0.sum();
    CoordInt off = {};
    Result result;
    for (size_t k = 0; k <= Dim; k++) {
        Coord ver = ver0 + off - g * k;
        Coord sep = t - ver;
        Float env = Float(0.5) - dot(sep, sep);
        if (env > 0) {
            Coord grad = gradient(tskew0 + off);
            Float proj = dot(grad, sep);
            result.value += (env * env) * proj;
            result.deriv += (env * env) * grad - (4 * env * proj) * sep;
        }
        if (k < Dim)
            off[reorder[k]]++;
    }

    // Apply gain and exponential saturation.
    result.value *= 20;
    result.deriv *= 20;
    if (pre::abs(result.value) > Float(0.5)) {
        Float sat = pre::exp(1 - 2 * pre::abs(result.value));
        result.value = pre::copysign(Float(1), result.value) * (1 - sat / 2);
        result.deriv *= sat;
    }
    return result;
}

template <std::floating_point Float = float>
using Noise1 = Noise<Float, 1>;

template <std::floating_point Float = float>
using Noise2 = Noise<Float, 2>;

template <std::floating_point Float = float>
using Noise3 = Noise<Float, 3>;

template <std::floating_point Float = float>
using Noise4 = Noise<Float, 4>;

} // namespace pre

#endif // #ifndef PRE_GRAPHICS_SIMPLEX_NOISE
