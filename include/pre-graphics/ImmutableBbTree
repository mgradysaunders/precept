/*-*- C++ -*-*/
/* Copyright (c) 2018-21 M. Grady Saunders
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *   1. Redistributions of source code must retain the above
 *      copyright notice, this list of conditions and the following
 *      disclaimer.
 *
 *   2. Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following
 *      disclaimer in the documentation and/or other materials
 *      provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/*-*-*-*-*-*-*/
#pragma once
#ifndef PRE_GRAPHICS_IMMUTABLE_BB_TREE
#define PRE_GRAPHICS_IMMUTABLE_BB_TREE

#include <pre/memory>
#include <pre-graphics/BoundBox>

namespace pre {

/// An immutable bounding volume hierarchy.
template <size_t Dim>
class ImmutableBbTree {
    static_assert(Dim == 2 or Dim == 3);

  public:
    using Box = BoundBox<float, Dim>;
    using Point = Array<float, Dim>;

    struct Node {
        /// Bound box.
        Box box;
        union {
            /// If branch, right child offset.
            std::uint32_t right;
            /// If leaf, first item.
            std::uint32_t first;
        };
        /// If leaf, item count.
        std::uint8_t count;
        /// If branch, split axis.
        std::uint8_t split_axis;

        constexpr bool is_leaf() const noexcept {
            return count != 0;
        }
        constexpr bool is_branch() const noexcept {
            return count == 0;
        }

        template <typename Range>
        constexpr auto values(const Range& range) const noexcept {
            ASSERT(count > 0);
            return IteratorRange(                    //
                    std::next(range.begin(), first), //
                    std::next(range.begin(), first + count));
        }

        void serialize(auto& serializer) {
            serializer <=> box;
            serializer <=> right;
            serializer <=> count;
            serializer <=> split_axis;
        }
    };

    struct Item {
        int index = 0;
        Box box;
        Point box_center;
    };

    using Nodes = std::vector<Node>;
    using Items = std::vector<Item>;

  public:
    void build(int leaf_limit, Items& items);

    void clear() {
        nodes.clear();
    }

    template <std::invocable<const Node*> Func>
    void ray_cast(const Ray<float, Dim>& ray, Func&& func) const {
        RayTester<Box> ray_tester(ray);
        StaticStack<const Node*, 64> todo;
        if (nodes.size() > 0)
            todo.push(&nodes[0]);
        while (not todo.empty()) {
            const Node* node = todo.pop();
            if (not ray_tester(node->box))
                continue; // Skip

            if (node->is_branch()) {
                todo.push(node + 1);
                todo.push(node + node->right);

                // If ray direction is positive in splitting dimension
                // of the branch, then reverse the traversal order of the
                // children, so that the left child is first.
                if (pre::signbit(ray.dir[node->split_axis]) == false)
                    std::swap(todo[-1], todo[-2]);
            }
            else {
                // Pass to leaf callback
                if (std::invoke(func, node) == false)
                    return;
            }
        }
    }

    void serialize(auto& serializer) {
        serializer <=> nodes;
    }

  public:
    Nodes nodes;
};

/// An immutable bounding volume hierarchy builder.
template <size_t Dim>
class ImmutableBbTreeBuilder {
    static_assert(Dim == 2 or Dim == 3);

  public:
    using Bvh = ImmutableBbTree<Dim>;
    using Box = typename Bvh::Box;
    using Item = typename Bvh::Item;
    using Items = typename Bvh::Items;

    struct Node {
        Box box = {};           ///< Box.
        Node* left = nullptr;   ///< If branch, left child.
        Node* right = nullptr;  ///< If branch, right child.
        ssize_t split_axis = 0; ///< If branch, split axis.
        ssize_t first_item = 0; ///< If leaf, first item index.
        ssize_t item_count = 0; ///< If leaf, item count.
    };

    Node* root = {};
    ssize_t leaf_limit = 4;
    ssize_t node_count = 0;
    HeapArena<> node_arena = {};

  public:
    /// Build.
    void build(Items& items) {
        ssize_t first_item = 0;
        root = build_range(
                first_item, {items.data(), items.data() + items.size()});
        ASSERT(first_item == items.size());
    }

    /// Build range recursively.
    Node* build_range(ssize_t& first_item, IteratorRange<Item*> items) {
        Node* node = new (node_arena) Node();
        node_count++;
        Box box;
        Box box_center;
        for (const Item& item : items) {
            box |= item.box;
            box_center |= item.box_center;
        }
        ssize_t split_axis = box_center.diag().argmax();
        ssize_t item_count = items.size();
        if (item_count <= leaf_limit) { // Leaf?
            *node = {box, nullptr, nullptr, 0, first_item, item_count};
            first_item += item_count;
        }
        else {
            Item* split = find_split_sah(box_center, split_axis, items);
            *node = {
                    box,
                    build_range(first_item, {items.begin(), split}),
                    build_range(first_item, {split, items.end()}),
                    split_axis,
                    0,
                    0};
        }
        return node;
    }

    /// Find split using surface area heuristic.
    static Item* find_split_sah(
            const Box& box_center,
            ssize_t split_axis,
            IteratorRange<Item*> items) {
        constexpr ssize_t Nbins = 8;
        using Bin = std::pair<Box, ssize_t>;
        if (box_center.min()[split_axis] == //
            box_center.max()[split_axis])
            return find_split_equal_counts(split_axis, items);

        // Initialize bins.
        std::array<Bin, Nbins> bins = {};
        for (const Item& item : items) {
            float cen = item.box_center[split_axis];
            float cen_min = box_center.min()[split_axis];
            float cen_max = box_center.max()[split_axis];
            int pos = std::min<int>(
                    Nbins * ((cen - cen_min) / (cen_max - cen_min)),
                    Nbins - 1);
            bins[pos].first |= item.box;
            bins[pos].second++;
        }

        // Initialize sweeps.
        std::array<Bin, Nbins - 1> lsweep;
        std::array<Bin, Nbins - 1> rsweep;
        {
            auto itrlsweep = lsweep.begin(), itrlbins = bins.begin();
            auto itrrsweep = rsweep.rbegin(), itrrbins = bins.rbegin();
            *itrlsweep++ = *itrlbins++;
            *itrrsweep++ = *itrrbins++;
            for (; itrlsweep < lsweep.end();
                 ++itrlsweep, ++itrlbins, ++itrrsweep, ++itrrbins) {
                itrlsweep->first = (itrlsweep - 1)->first | itrlbins->first;
                itrrsweep->first = (itrrsweep - 1)->first | itrrbins->first;
                itrlsweep->second = (itrlsweep - 1)->second + itrlbins->second;
                itrrsweep->second = (itrrsweep - 1)->second + itrrbins->second;
            }
        }

        // Compute costs.
        Array<float, Nbins - 1> costs;
        {
            auto itrcosts = costs.begin();
            auto itrlsweep = lsweep.begin();
            auto itrrsweep = rsweep.begin();
            for (; itrrsweep < rsweep.end();
                 ++itrcosts, ++itrlsweep, ++itrrsweep)
                *itrcosts =
                        itrlsweep->first.surface_area() * itrlsweep->second +
                        itrrsweep->first.surface_area() * itrrsweep->second;
        }

        // Partition.
        int costs_argmin = costs.argmin();
        Item* split = std::partition(
                items.begin(), items.end(), [=](const Item& item) {
                    float cen = item.box_center[split_axis];
                    float cen_min = box_center.min()[split_axis];
                    float cen_max = box_center.max()[split_axis];
                    int pos = std::min<int>(
                            Nbins * ((cen - cen_min) / (cen_max - cen_min)),
                            Nbins - 1);
                    return pos <= costs_argmin;
                });

        // Partition successful?
        if (split != items.begin() and //
            split != items.end())
            return split;
        else
            return find_split_equal_counts(split_axis, items);
    }

    /// Find split using equal counts.
    static Item* find_split_equal_counts(
            ssize_t split_axis, IteratorRange<Item*> items) {
        Item* split = items.begin() + items.size() / 2;
        std::nth_element(
                items.begin(), split, items.end(),
                [=](const Item& item0, //
                    const Item& item1) -> bool {
                    return item0.box_center[split_axis] <
                           item1.box_center[split_axis];
                });
        return split;
    }

    /// Collapse.
    static void collapse(Node* from, auto& nodes) {
        ASSERT(from);
        nodes.emplace_back();
        auto& node = nodes.back();
        node.box = from->box;
        if (from->item_count > 0) {
            ASSERT(not from->left);
            ASSERT(not from->right);
            node.first = from->first_item;
            node.count = from->item_count;
            node.split_axis = 0;
        }
        else {
            collapse(from->left, nodes);
            node.right = &nodes.back() - &node + 1;
            node.count = 0;
            node.split_axis = from->split_axis;
            collapse(from->right, nodes);
        }
    }
};

template <size_t Dim>
inline void ImmutableBbTree<Dim>::build(int leaf_limit, Items& items) {
    if (leaf_limit < 1)
        leaf_limit = 1;

    // Run builder.
    ImmutableBbTreeBuilder<Dim> builder;
    builder.leaf_limit = leaf_limit;
    builder.build(items);

    // Collapse.
    nodes.clear();
    nodes.reserve(builder.node_count);
    ImmutableBbTreeBuilder<Dim>::collapse(builder.root, nodes);
}

using ImmutableBbTree2 = ImmutableBbTree<2>;

using ImmutableBbTree3 = ImmutableBbTree<3>;

} // namespace pre

#endif // #ifndef PRE_GRAPHICS_IMMUTABLE_BB_TREE
