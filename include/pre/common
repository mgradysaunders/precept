/*-*- C++ -*-*/
/* Copyright (c) 2018-20 M. Grady Saunders
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *   1. Redistributions of source code must retain the above
 *      copyright notice, this list of conditions and the following
 *      disclaimer.
 *
 *   2. Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following
 *      disclaimer in the documentation and/or other materials
 *      provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/*-*-*-*-*-*-*/
#if !(__cplusplus >= 201709L)
#error "Precept requires >= C++20"
#endif // #if !(__cplusplus >= 201709L)
#pragma once
#ifndef PRE_CONCEPTS
#define PRE_CONCEPTS

// for std::array
#include <array>

// for std::find
#include <algorithm>

// for std::basic_istream, std::basic_ostream, ...
#include <iosfwd>

// for assert
#include <cassert>

// for std::max_align_t
#include <cstddef>

// for std::complex
#include <complex>

// for std::semiregular, std::regular, ...
#include <concepts>

// for std::input_or_output_iterator, std::random_access_iterator, ...
#include <iterator>

// for std::ranges::range
#include <ranges>

// for std::tuple_element
#include <utility>

// for std::is_base_of_v, std::is_arithmetic_v, ...
#include <type_traits>

namespace pre {

template <typename>
struct to_floating_point;

template <typename... T>
using to_floating_point_t =
        typename to_floating_point<std::common_type_t<T...>>::type;

template <std::integral T>
struct to_floating_point<T> {
    using type = double;
};

template <std::floating_point T>
struct to_floating_point<T> {
    using type = T;
};

template <std::floating_point T>
struct to_floating_point<std::complex<T>> {
    using type = T;
};

template <typename T>
struct to_floating_point<T&> {
    using type = to_floating_point_t<T>; // Strip reference
};

namespace concepts {

/// Is type a pointer?
template <typename T>
concept pointer = std::is_pointer_v<T>;

/// Is type a reference?
template <typename T>
concept reference = std::is_reference_v<T>;

/// Is type an lvalue reference?
template <typename T>
concept lvalue_reference = std::is_lvalue_reference_v<T>;

/// Is type an rvalue reference?
template <typename T>
concept rvalue_reference = std::is_rvalue_reference_v<T>;

/// Is type a subclass of X?
template <typename T, typename X>
concept subclass = std::is_base_of_v<X, T>;

/// Is type a superclass of X?
template <typename T, typename X>
concept superclass = std::is_base_of_v<T, X>;

// Is instantiation?
template <typename, template <typename...> typename>
struct is_instantiation : std::false_type {};

// Is instantiation? true specialization.
template <typename... Ts, template <typename...> typename X>
struct is_instantiation<X<Ts...>, X> : std::true_type {};

/// Matches template?
template <typename T, template <typename...> typename X>
concept matches = is_instantiation<T, X>::value;

/// Does not match template?
template <typename T, template <typename...> typename X>
concept not_matches = !is_instantiation<T, X>::value;

/// Matches `std::basic_istream`?
template <typename T>
concept istream = requires {
    requires subclass<
            T, std::basic_istream<
                       typename T::char_type, typename T::traits_type>>;
};

/// Matches `std::basic_ostream`?
template <typename T>
concept ostream = requires {
    requires subclass<
            T, std::basic_ostream<
                       typename T::char_type, typename T::traits_type>>;
};

// Is arithmetic?
template <typename T>
concept arithmetic = std::is_arithmetic_v<T>;

// Is arithmetic or enum?
template <typename T>
concept arithmetic_or_enum = std::is_arithmetic_v<T> || std::is_enum_v<T>;

/// Is arithmetic or standard complex?
template <typename T>
concept arithmetic_or_complex = arithmetic<T> || matches<T, std::complex>;

/// Is floating point or standard complex?
template <typename T>
concept floating_point_or_complex =
        std::floating_point<T> || matches<T, std::complex>;

// Is functor?
template <typename T>
concept functor = requires {
    requires std::is_member_function_pointer_v<decltype(&T::operator())>;
};

/// Is minimal container?
template <typename T>
concept minimal_container = requires(T& c) {
    requires std::default_initializable<T>;
    requires std::destructible<T>;
    requires std::signed_integral<typename T::difference_type>;
    requires std::unsigned_integral<typename T::size_type>;
    { c.begin() }
    ->std::convertible_to<typename T::iterator>;
    { c.end() }
    ->std::convertible_to<typename T::iterator>;
    { c.cbegin() }
    ->std::convertible_to<typename T::const_iterator>;
    { c.cend() }
    ->std::convertible_to<typename T::const_iterator>;
    { c.size() }
    ->std::convertible_to<typename T::size_type>;
};

/// Is allocator aware?
template <typename T>
concept allocator_aware = requires(T& c) {
    requires std::constructible_from<T, const T&, typename T::allocator_type>;
    requires std::constructible_from<T, T&&, typename T::allocator_type>;
    requires std::assignable_from<T, const T&>;
    requires std::assignable_from<T, T&&>;
    { c.get_allocator() }
    ->std::convertible_to<typename T::allocator_type>;
};

/// Is sequence constructible?
template <typename T>
concept sequence_constructible = requires {
    requires std::constructible_from<
            T, const typename T::value_type*, const typename T::value_type*>;
};

/// Is trivially_destructible?
template <typename T>
concept trivially_destructible = std::is_trivially_destructible_v<T>;

/// Is random access range of given value type?
template <typename T, typename Value>
concept random_access_range_of = requires {
    requires std::ranges::random_access_range<T>;
    requires std::convertible_to<std::ranges::range_value_t<T>*, Value*>;
};

} // namespace concepts

/// A type list.
template <typename... T>
struct type_list {
    template <size_t N>
    using type = typename std::tuple_element<N, std::tuple<T...>>::type;
};

/// A type list concatenator.
template <typename T, typename U>
struct type_list_cat {
    using type = type_list<T, U>;
};

template <typename T, typename... U>
struct type_list_cat<T, type_list<U...>> {
    using type = type_list<T, U...>;
};

template <typename... T, typename U>
struct type_list_cat<type_list<T...>, U> {
    using type = type_list<T..., U>;
};

template <typename... T, typename... U>
struct type_list_cat<type_list<T...>, type_list<U...>> {
    using type = type_list<T..., U...>;
};

/// An indexed type.
template <size_t N, typename T>
struct indexed_type {
    static constexpr size_t index = N;
    using type = T;
};

/// An indexed type list.
template <size_t N, typename... T>
struct indexed_type_list;

template <typename... T>
using indexed_type_list_t = typename indexed_type_list<0, T...>::type;

template <size_t N, typename T, typename... U>
struct indexed_type_list<N, T, U...> {
    using type = typename type_list_cat<
            indexed_type<N, T>,
            typename indexed_type_list<N + 1, U...>::type>::type;
};

template <size_t N, typename T>
struct indexed_type_list<N, T> {
    using type = type_list<indexed_type<N, T>>;
};

template <>
struct indexed_type_list<0> {
    using type = type_list<>;
};

/// A callable indexed type list.
template <typename T>
struct callable_indexed_type_list;

template <typename T>
using callable_indexed_type_list_t =
        typename callable_indexed_type_list<T>::type;

template <typename T, typename... Args>
struct callable_indexed_type_list<T(Args...)> {
    using type = indexed_type_list_t<Args...>;
};

template <typename T, typename... Args>
struct callable_indexed_type_list<T (*)(Args...)> {
    using type = indexed_type_list_t<Args...>;
};

template <typename T, typename Class, typename... Args>
struct callable_indexed_type_list<T (Class::*)(Args...)> {
    using type = indexed_type_list_t<Args...>;
};

template <typename T, typename Class, typename... Args>
struct callable_indexed_type_list<T (Class::*)(Args...) const> {
    using type = indexed_type_list_t<Args...>;
};

template <concepts::functor T>
struct callable_indexed_type_list<T>
    : callable_indexed_type_list<decltype(&T::operator())> {};

template <typename T>
struct callable_indexed_type_list<T&> : callable_indexed_type_list<T> {};

template <typename T>
struct callable_indexed_type_list<T&&> : callable_indexed_type_list<T> {};

/// An iterator range.
template <std::input_or_output_iterator Iterator>
class IteratorRange {
  public:
    typedef typename std::iterator_traits<Iterator>::value_type value_type;

    typedef typename std::iterator_traits<Iterator>::pointer pointer;

    typedef typename std::iterator_traits<Iterator>::reference reference;

    typedef typename std::iterator_traits<Iterator>::difference_type
            difference_type;

  public:
    constexpr IteratorRange() = default;

    constexpr IteratorRange(Iterator from, Iterator to)
        : begin_(from), end_(to) {
    }

    constexpr IteratorRange(const std::pair<Iterator, Iterator>& from_to)
        : begin_(from_to.first), end_(from_to.second) {
    }

    template <std::ranges::range Range>
    constexpr IteratorRange(Range&& range)
        : begin_(std::ranges::begin(range)), end_(std::ranges::end(range)) {
    }

    constexpr IteratorRange(const IteratorRange&) = default;

    constexpr IteratorRange(IteratorRange&&) = default;

    constexpr Iterator begin() {
        return begin_;
    }

    constexpr Iterator end() {
        return end_;
    }

    constexpr difference_type size() const {
        return empty() ? 0 : std::distance(begin_, end_);
    }

    constexpr bool empty() const {
        return begin_ == end_;
    }

    constexpr reference front() {
        return operator[](0);
    }

    constexpr reference back() {
        return operator[](size() - 1);
    }

    constexpr reference operator[](difference_type pos) {
        return *std::next(begin_, pos);
    }

    template <typename Other>
    constexpr operator IteratorRange<Other>() {
        return {Other(begin_), Other(end_)};
    }

    template <typename Value>
    constexpr bool contains(const Value& val) {
        return std::find(begin_, end_, val) != end_;
    }

  public:
    constexpr IteratorRange& operator=(const IteratorRange&) = default;

    constexpr IteratorRange& operator=(IteratorRange&&) = default;

  private:
    Iterator begin_ = {};

    Iterator end_ = {};
};

template <std::input_or_output_iterator Iterator>
IteratorRange(const Iterator&, const Iterator&) -> IteratorRange<Iterator>;

template <std::input_or_output_iterator Iterator>
IteratorRange(const std::pair<Iterator, Iterator>&) -> IteratorRange<Iterator>;

template <std::ranges::range Range>
IteratorRange(Range&&) -> IteratorRange<std::ranges::iterator_t<Range>>;

/// Array-like CRTP.
template <typename Subclass, typename Value, bool NegativeFromBack = true>
struct ArrayLike {

    typedef size_t size_type;

    typedef std::ptrdiff_t difference_type;

    typedef Value value_type;

    typedef value_type& reference;

    typedef value_type* pointer;

    typedef const value_type& const_reference;

    typedef const value_type* const_pointer;

    typedef pointer iterator;

    typedef const_pointer const_iterator;

    typedef std::reverse_iterator<iterator> reverse_iterator;

    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

    constexpr bool empty() const noexcept {
        return static_cast<const Subclass&>(*this).size() == 0;
    }

    constexpr const_iterator cbegin() const noexcept {
        return static_cast<const Subclass&>(*this).begin();
    }

    constexpr const_iterator cend() const noexcept {
        return static_cast<const Subclass&>(*this).end();
    }

    constexpr reverse_iterator rbegin() noexcept {
        return reverse_iterator(static_cast<Subclass&>(*this).end());
    }

    constexpr const_reverse_iterator rbegin() const noexcept {
        return const_reverse_iterator(
                static_cast<const Subclass&>(*this).end());
    }

    constexpr const_reverse_iterator crbegin() const noexcept {
        return rbegin(); // Force const
    }

    constexpr reverse_iterator rend() noexcept {
        return reverse_iterator(static_cast<Subclass&>(*this).begin());
    }

    constexpr const_reverse_iterator rend() const noexcept {
        return const_reverse_iterator(
                static_cast<const Subclass&>(*this).begin());
    }

    constexpr const_reverse_iterator crend() const noexcept {
        return rend(); // Force const
    }

    constexpr reference front() noexcept {
        return *static_cast<Subclass&>(*this).begin();
    }

    constexpr const_reference front() const noexcept {
        return *static_cast<const Subclass&>(*this).begin();
    }

    constexpr reference back() noexcept {
        return *rbegin();
    }

    constexpr const_reference back() const noexcept {
        return *rbegin();
    }

    constexpr pointer data() noexcept {
        return static_cast<Subclass&>(*this).begin();
    }

    constexpr const_pointer data() const noexcept {
        return static_cast<const Subclass&>(*this).begin();
    }

    template <std::integral Int>
    constexpr reference operator[](Int pos) noexcept {
        if constexpr (std::signed_integral<Int> && NegativeFromBack)
            if (pos < 0)
                pos += static_cast<Subclass&>(*this).size();
        return *(static_cast<Subclass&>(*this).begin() + pos);
    }

    template <std::integral Int>
    constexpr const_reference operator[](Int pos) const noexcept {
        if constexpr (std::signed_integral<Int> && NegativeFromBack)
            if (pos < 0)
                pos += static_cast<const Subclass&>(*this).size();
        return *(static_cast<const Subclass&>(*this).begin() + pos);
    }

    template <std::integral Int>
    constexpr reference at(Int pos) {
        Int sz = static_cast<Subclass&>(*this).size();
        if constexpr (std::signed_integral<Int> && NegativeFromBack)
            if (pos < 0)
                pos += sz;
        if (pos < 0 || pos >= sz)
            throw std::out_of_range(__func__);
        return *(static_cast<Subclass&>(*this).begin() + pos);
    }

    template <std::integral Int>
    constexpr const_reference at(Int pos) const {
        Int sz = static_cast<const Subclass&>(*this).size();
        if constexpr (std::signed_integral<Int> && NegativeFromBack)
            if (pos < 0)
                pos += sz;
        if (pos < 0 || pos >= sz)
            throw std::out_of_range(__func__);
        return *(static_cast<const Subclass&>(*this).begin() + pos);
    }
};

/// An RAII scoped management helper.
///
/// \tparam F  A function object to call on construction.
/// \tparam G  A function object to call on destruction.
///
template <typename F, typename G>
struct Scoped {
    constexpr Scoped(F&& f, G&& g) : g_(std::forward<G>(g)) {
        std::invoke(f);
    }
    constexpr ~Scoped() {
        std::invoke(g_);
    }

    // Non-copyable.
    Scoped(const Scoped&) = delete;

  private:
    G g_;
};

template <typename F, typename G>
Scoped(F&&, G&&) -> Scoped<F, G>;

using ssize_t = std::make_signed_t<size_t>;

#if NDEBUG
#define ASSERT(what) void(0)
#else
#define ASSERT(what) ((what) ? void(0) : [] { assert(!#what); }())
#endif // #if NDEBUG

} // namespace pre

#endif // #ifndef PRE_CONCEPTS
