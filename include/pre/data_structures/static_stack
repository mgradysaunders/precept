/*-*- C++ -*-*/
/* Copyright (c) 2018-21 M. Grady Saunders
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *   1. Redistributions of source code must retain the above
 *      copyright notice, this list of conditions and the following
 *      disclaimer.
 *
 *   2. Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following
 *      disclaimer in the documentation and/or other materials
 *      provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/*-*-*-*-*-*-*/
#if !(__cplusplus >= 201709L)
#error "Precept requires >= C++20"
#endif // #if !(__cplusplus >= 201709L)
#pragma once
#ifndef PRE_DATA_STRUCTURES_STATIC_STACK
#define PRE_DATA_STRUCTURES_STATIC_STACK

// for std::runtime_error, std::length_error, ...
#include <stdexcept>

#include <pre/common>

namespace pre {

/// A static stack.
///
/// A static stack (first-in last-out), where elements are
/// pushed onto and popped from the top/back.
///
template <typename Value, size_t MaxSize>
struct StaticStack : ArrayLike<StaticStack<Value, MaxSize>, Value> {
  public:
    constexpr StaticStack() noexcept = default;

    template <std::input_or_output_iterator Iterator>
    constexpr StaticStack(Iterator from, Iterator to) {
        while (from != to)
            push(*from++);
    }

  public:

    /// \name Container API
    /** \{ */

    constexpr size_t size() const noexcept {
        return top_;
    }

    constexpr size_t max_size() const noexcept {
        return MaxSize;
    }

    constexpr size_t capacity() const noexcept {
        return MaxSize;
    }

    constexpr Value* begin() noexcept {
        return &values_[0];
    }

    constexpr const Value* begin() const noexcept {
        return &values_[0];
    }

    constexpr Value* end() noexcept {
        return &values_[0] + top_;
    }

    constexpr const Value* end() const noexcept {
        return &values_[0] + top_;
    }

    constexpr bool empty() const noexcept {
        return top_ == 0;
    }

    constexpr bool full() const noexcept {
        return top_ == MaxSize;
    }

    constexpr void clear() noexcept {
        for (auto& value : *this)
            value.~Value();
        top_ = 0;
    }

    /** \} */

public:
    /// \name Stack API
    /** \{ */

    /// Bottom/front value with empty check.
    ///
    /// \throw std::runtime_error  If empty.
    ///
    constexpr decltype(auto) bottom() {
        if (empty())
            throw std::runtime_error(__func__);
        return this->front();
    }

    /// Bottom/front value with empty check, const variant.
    ///
    /// \throw std::runtime_error  If empty.
    ///
    constexpr decltype(auto) bottom() const {
        if (empty())
            throw std::runtime_error(__func__);
        return this->front();
    }

    /// Top/back value with empty check.
    ///
    /// \throw std::runtime_error  If empty.
    ///
    constexpr decltype(auto) top() {
        if (empty())
            throw std::runtime_error(__func__);
        return this->back();
    }

    /// Top/back value with empty check, const variant.
    ///
    /// \throw std::runtime_error  If empty.
    ///
    constexpr decltype(auto) top() const {
        if (empty())
            throw std::runtime_error(__func__);
        return this->back();
    }

    /// Pop and return top/back value.
    ///
    /// \throw std::runtime_error  If empty.
    ///
    constexpr Value pop() {
        if (top_ == 0)
            throw std::runtime_error(__func__);
        Value& value = values_[--top_];
        Value result = std::move(value);
        value.~Value();
        return result;
    }

    /// Push top/back value.
    ///
    /// \throw std::length_error  If full.
    ///
    constexpr void push(const Value& value) {
        if (top_ >= MaxSize)
            throw std::length_error(__func__);
        values_[top_++] = value;
    }

    /** \} */

  public:
    void serialize(auto& serializer) {
        serializer <=> values_;
        serializer <=> top_;
    }

  private:
    Value values_[MaxSize] = {};

    size_t top_ = 0;
};

} // namespace pre

#endif // #ifndef PRE_DATA_STRUCTURES_STATIC_STACK
