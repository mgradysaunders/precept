/*-*- C++ -*-*/
/* Copyright (c) 2018-20 M. Grady Saunders
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *   1. Redistributions of source code must retain the above
 *      copyright notice, this list of conditions and the following
 *      disclaimer.
 *
 *   2. Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following
 *      disclaimer in the documentation and/or other materials
 *      provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/*-*-*-*-*-*-*/
#if !(__cplusplus >= 201709L)
#error "Precept requires >= C++20"
#endif // #if !(__cplusplus >= 201709L)
#pragma once
#ifndef PRE_DATA_STRUCTURES_KD_TREE
#define PRE_DATA_STRUCTURES_KD_TREE

#include <variant>
#include <pre/array>
#include <pre/data_structures/link_list>
#include <pre/data_structures/static_stack>
#include <pre/memory/mem_pool>
#include <pre/shapes/bound_box>

namespace pre {

/// A kd-tree.
///
/// This structure defines a constructible, editable, iterable interface
/// to a kd-tree. A kd-tree generalizes the idea of a 1 dimensional binary
/// tree to k dimensions. Every node in the tree stores a value at a particular
/// location and divides its local space into two half spaces in 1 of the k
/// dimensions. This permits logarithmic-time insertion and search operations
/// on average.
///
/// To simplify things, this structure implements constant-time erase
/// operations, so that `erase()` deconstructs values but does not actually
/// modify the tree. After many calls to `insert()` and/or `erase()`, the tree
/// may be very imbalanced, and there may be many erased nodes taking up space
/// without serving any purpose. To rebalance the tree and free erased nodes,
/// the user must call `rebalance()`.
///
/// \tparam Float  Float type.
/// \tparam N      Array dimension.
/// \tparam T      Mapped type.
/// \tparam Alloc  Allocator type.
///
template <
        std::floating_point Float,
        size_t N,
        typename T,
        typename Alloc = std::allocator<T>>
class KdTree {
  public:
    typedef size_t size_type;
    typedef std::ptrdiff_t difference_type;
    typedef Array<Float, N> key_type;
    typedef T mapped_type;
    typedef std::pair<const key_type, mapped_type> value_type;
    typedef value_type& reference;
    typedef value_type* pointer;
    typedef const value_type& const_reference;
    typedef const value_type* const_pointer;

    struct Node {
        Node* next;       ///< Next.
        Node* left;       ///< Left child.
        Node* right;      ///< Right child.
        int axis;         ///< Comparison axis.
        value_type value; ///< Value.
        bool has_value;   ///< Has value?

        /// \name Link API
        /** \{ */

        constexpr auto* value_ptr() noexcept {
            return &value;
        }

        constexpr auto* value_ptr() const noexcept {
            return &value;
        }

        constexpr bool should_ignore() const noexcept {
            return !has_value;
        }

        /** \} */
    };

    typedef LinkIterator<Node*> iterator;
    typedef LinkIterator<const Node*> const_iterator;

  public:
    KdTree(const Alloc& alloc = {}) : pool_(sizeof(Node), 0, alloc) {
    }

    KdTree(const KdTree&) = delete;

    KdTree(KdTree&& other)
        : pool_(std::move(other.pool)),
          root_(std::exchange(other.root_, nullptr)),
          head_(std::exchange(other.head_, nullptr)),
          size_(std::exchange(other.size_, 0)),
          size_erased_(std::exchange(other.size_erased_, 0)),
          depth_(std::exchange(other.depth_, 0)) {
    }

    ~KdTree() {
        clear();
    }

    KdTree& operator=(const KdTree&) = delete;

    KdTree& operator=(KdTree&& other) {
        pool_ = std::move(other.pool_);
        root_ = std::exchange(other.root_, nullptr);
        head_ = std::exchange(other.head_, nullptr);
        size_ = std::exchange(other.size_, nullptr);
        size_erased_ = std::exchange(other.size_erased_, nullptr);
        depth_ = std::exchange(other.depth_, nullptr);
        return *this;
    }

  public:
    /// \name Container API
    /** \{ */

    size_type size() const noexcept {
        return size_;
    }

    bool empty() const noexcept {
        return size_ == 0;
    }

    iterator begin() noexcept {
        return head_;
    }

    const_iterator begin() const noexcept {
        return head_;
    }

    const_iterator cbegin() const noexcept {
        return begin(); // Force const
    }

    iterator end() noexcept {
        return nullptr;
    }

    const_iterator end() const noexcept {
        return nullptr;
    }

    const_iterator cend() const noexcept {
        return end(); // Force const
    }

    /// Insert value.
    ///
    /// \note
    /// This inserts the value into the tree quickly without
    /// disturbing other iterators. The insertion is not guaranteed
    /// to be optimal. After some considerable number of calls to
    /// `insert()`, it is advisable to call `rebalance()` to
    /// optimize the tree.
    ///
    iterator insert(const value_type& value) {
        Node* node = static_cast<Node*>(pool_.allocate());
        node->next = node->left = node->right = nullptr;
        node->axis = 0;
        new (&node->value) value_type(value);
        node->has_value = true;
        if (root_ == nullptr) {
            root_ = node;
            head_ = node;
        }
        else {
            insert_(root_, node);
            node->next = head_;
            head_ = node;
        }
        size_++;
        return node;
    }

    /// Erase value.
    ///
    /// \note
    /// This deconstructs the value at the given iterator, but
    /// does not actually modify the tree. This simply marks the
    /// node as erased. This does not really matter from the user
    /// perspective, in that advancing an `iterator` automatically
    /// skips erased nodes. After some considerable number of calls
    /// to `erase()` however, it is advisable to call `rebalance()`
    /// to optimize the tree.
    ///
    /// \pre
    /// - The `pos` iterator is valid.
    ///
    /// \post
    /// - The `pos` iterator is invalid.
    ///
    /// \returns
    /// Returns next iterator, as if by `std::next(pos)`.
    ///
    iterator erase(const_iterator pos) noexcept {
        Node* node = const_cast<Node*>(pos.link);
        ASSERT(node);
        ASSERT(node->has_value == true);
        node->has_value = false;
        if constexpr (!concepts::trivially_destructible<T>)
            node->value.second.~T();
        size_--;
        size_erased_++;
        return node->next;
    }

    void clear() {
        if constexpr (!concepts::trivially_destructible<T>)
            for (auto& value : *this)
                value.second.~T();
        pool_.reset();
        root_ = nullptr;
        head_ = nullptr;
        size_ = 0;
        size_erased_ = 0;
        depth_ = 0;
    }

    /** \} */

  public:
    /// Root accessor.
    ///
    /// This accessor is provided so that client code can implement
    /// custom recursive processing routines. Be careful!
    ///
    const Node* root() const noexcept {
        return root_;
    }

    /// Box accessor.
    const BoundBox<Float, N>& box() const noexcept {
        return box_;
    }

    /// Depth.
    ///
    /// This is the depth of the deepest leaf.
    ///
    size_type depth() const noexcept {
        return depth_;
    }

    /// Optimal depth.
    ///
    /// This is the approximate depth of the deepest leaf if the
    /// tree were perfectly balanced, which is calculated by rounding
    /// up `size()` to the next power of 2, then taking the base-2
    /// logarithm.
    ///
    size_type optimal_depth() const noexcept {
        return first1(roundpow2(size_));
    }

    /// Should rebalance?
    ///
    /// This is a heuristic to help client code decide when to
    /// rebalance the tree. This returns true if the deepest leaf is
    /// more than twice the optimal depth, of if more than half of all
    /// nodes have been erased.
    ///
    bool should_rebalance() const noexcept {
        return depth() > 2 * optimal_depth() || size_erased_ > size_;
    }

    /// Rebalance.
    ///
    /// This rebalances the tree by reorganizing all nodes. This is an
    /// expensive operation, but optimizes the tree structure such that
    /// subsequent operations perform more efficiently.
    ///
    void rebalance() {
        if (empty())
            return;
        // Collect nodes.
        std::vector<Node*> nodes;
        nodes.reserve(size_);
        box_ = {};
        for (Node* node = head_; node;) {
            if (node->has_value == false) {
                Node* next = node->next;
                pool_.deallocate(node);
                node = next;
            }
            else {
                box_ |= node->value.first;
                nodes.emplace_back(node);
                node = node->next;
            }
        }
        // Rebalance and relink.
        depth_ = 0;
        size_erased_ = 0;
        root_ = rebalance_(0, {&nodes[0], &nodes[0] + nodes.size()});
        head_ = nodes[0];
        for (auto itr = nodes.begin(); itr + 1 < nodes.end(); ++itr)
            (*itr)->next = *(itr + 1);
    }

  private:
    /// Traversal helper.
    struct Traversal {
        using Heap = std::vector<Node*>;
        using NoHeap = StaticStack<Node*, 64>;

      public:
        Traversal(const KdTree& tree) {
            if (tree.depth() >= 64) {
                nodes_ = Heap();
                std::get<Heap>(nodes_).reserve(2 * tree.optimal_depth());
            }
            else
                nodes_ = NoHeap();
            if (tree.root())
                push(const_cast<Node*>(tree.root()));
        }

        void push(Node* node) {
            if (std::holds_alternative<Heap>(nodes_))
                std::get<Heap>(nodes_).push_back(node);
            else
                std::get<NoHeap>(nodes_).push(node);
        }

        Node* pop() {
            if (std::holds_alternative<Heap>(nodes_)) {
                auto& nodes = std::get<Heap>(nodes_);
                Node* node = nodes.back();
                nodes.pop_back();
                return node;
            }
            else
                return std::get<NoHeap>(nodes_).pop();
        }

        bool empty() {
            if (std::holds_alternative<Heap>(nodes_))
                return std::get<Heap>(nodes_).empty();
            else
                return std::get<NoHeap>(nodes_).empty();
        }

      private:
        std::variant<Heap, NoHeap> nodes_;
    };

  public:
    /// Visit nearby values.
    ///
    /// \param[in] center  Search center.
    /// \param[in] radius  Search radius.
    /// \param[in] func    Predicate function with signature `bool(iterator)`.
    ///
    template <std::predicate<iterator> Pred>
    bool visit_nearby(
            Array<Float, N> center, Float radius, Pred&& pred) const {
        Traversal todo(*this);
        while (!todo.empty()) {
            // If node in radius, pass to predicate.
            Node* node = todo.pop();
            Array<Float, N> diff = node->value.first - center;
            if (node->has_value && length2(diff) < radius * radius)
                if (!std::invoke(pred, iterator(node)))
                    return false;
            // Recurse as necessary.
            if (diff[node->axis] > -radius && node->left)
                todo.push(node->left);
            if (diff[node->axis] < +radius && node->right)
                todo.push(node->right);
        }
        return true;
    }

    /// Erase nearby values.
    ///
    /// \param[in] center  Search center.
    /// \param[in] radius  Search radius.
    ///
    /// \returns
    /// Returns number of values erased.
    ///
    size_type erase_nearby(Array<Float, N> center, Float radius) {
        size_type count = 0;
        auto pred = [&](auto pos) {
            count++;
            erase(pos);
            return true; // Keep going.
        };
        (void)visit_nearby(center, radius, pred);
        return count;
    }

    /// Count nearby values.
    ///
    /// \param[in] center  Search center.
    /// \param[in] radius  Search radius.
    ///
    size_type count_nearby(Array<Float, N> center, Float radius) const {
        size_type count = 0;
        auto pred = [&](auto) {
            count++;
            return true; // Keep going.
        };
        (void)visit_nearby(center, radius, pred);
        return count;
    }

    /// Find nearest.
    iterator nearest(Array<Float, N> center) const {
        Node* result = nullptr;
        Float result_dist2 = pre::numeric_limits<Float>::infinity();
        Traversal todo(*this);
        while (!todo.empty()) {
            // Update result.
            Node* node = todo.pop();
            Array<Float, N> diff = node->value.first - center;
            Array<Float, N> diff2 = diff * diff;
            if (node->has_value) {
                Float dist2 = diff2.sum();
                if (result_dist2 > dist2) {
                    result_dist2 = dist2;
                    result = node;
                }
            }
            // Recurse as necessary.
            bool visit_both = diff2[node->axis] < result_dist2;
            if ((visit_both || diff[node->axis] > 0) && node->left)
                todo.push(node->left);
            if ((visit_both || diff[node->axis] < 0) && node->right)
                todo.push(node->right);
        }
        return result;
    }

  private:
    MemPool<Alloc> pool_;       ///< Node pool.
    Node* root_ = nullptr;      ///< Root.
    Node* head_ = nullptr;      ///< Head of list.
    size_type size_ = 0;        ///< Number of nodes.
    size_type size_erased_ = 0; ///< Number of nodes erased since rebalance.
    size_type depth_ = 0;       ///< Depth of deepest leaf.
    BoundBox<Float, N> box_;    ///< Box around all nodes.

  private:
    void insert_(Node*& node, Node* leaf, size_type depth = 0) {
        Node*& child =
                leaf->value.first[node->axis] < node->value.first[node->axis]
                        ? node->left
                        : node->right;
        if (child == nullptr) {
            child = leaf;
            leaf->axis = (node->axis + 1) % N;
            if (depth_ < depth)
                depth_ = depth;
        }
        else {
            insert_(child, leaf, depth + 1);
        }
    }

    Node* rebalance_(size_type depth, IteratorRange<Node**> nodes) {
        if (nodes.size() == 0) {
            return nullptr;
        }
        if (nodes.size() == 1) {
            Node* node = nodes[0];
            node->next = nullptr;
            node->left = nullptr;
            node->right = nullptr;
            node->axis = 0;
            if (depth_ < depth)
                depth_ = depth;
            return node;
        }
        BoundBox<Float, N> box;
        for (const Node* node : nodes)
            box |= node->value.first;
        int axis = box.diag().argmax();
        Node** middle = nodes.begin() + nodes.size() / 2;
        std::nth_element(
                nodes.begin(), middle, nodes.end(),
                [=](const Node* node0, const Node* node1) {
                    return node0->value.first[axis] < node1->value.first[axis];
                });
        depth += 1;
        (*middle)->next = nullptr;
        (*middle)->axis = axis;
        (*middle)->left = rebalance_(depth, {nodes.begin(), middle});
        (*middle)->right = rebalance_(depth, {middle + 1, nodes.end()});
        return *middle;
    }
};

template <
        std::floating_point Float,
        typename T,
        typename Alloc = std::allocator<T>>
using KdTree2 = KdTree<Float, 2, T, Alloc>;

template <
        std::floating_point Float,
        typename T,
        typename Alloc = std::allocator<T>>
using KdTree3 = KdTree<Float, 3, T, Alloc>;

} // namespace pre

#endif // #ifndef PRE_DATA_STRUCTURES_KD_TREE
