/*-*- C++ -*-*/
/* Copyright (c) 2018-21 M. Grady Saunders
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *   1. Redistributions of source code must retain the above
 *      copyright notice, this list of conditions and the following
 *      disclaimer.
 *
 *   2. Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following
 *      disclaimer in the documentation and/or other materials
 *      provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/*-*-*-*-*-*-*/
#if !(__cplusplus >= 201709L)
#error "Precept requires >= C++20"
#endif // #if !(__cplusplus >= 201709L)
#pragma once
#ifndef PRE_DATA_STRUCTURES_ADJACENCY_LISTS
#define PRE_DATA_STRUCTURES_ADJACENCY_LISTS

// for std::initializer_list
#include <initializer_list>

// for std::unordered_map
#include <map>

// for std::monostate
#include <variant>

// for pre::IteratorRange, pre::LinkList
#include <pre/meta>

// for pre::MemoryPool
#include <pre/data_structures/memory_pool>

namespace pre {

/// A set of adjacency lists.
///
/// This structure represents adjacency information between keys of
/// as a set of link-lists encoded in a hash table. As such, finding the
/// neighbor list of a given key happens in constant time on average, but
/// searching over the neighbors is linear with the number of neighbors.
/// So, this structure is meant to represent sparsely connected keys,
/// where the number of neighbors of any key is generally much less than
/// the total number of keys.
///
/// Also, this structure is undirected, meaning that if key _Foo_ is
/// connected to key _Bar_, then _Bar_ is also connected to _Foo_. Directed
/// connectivity information can be represented by using this structure
/// in combination with `DirectedEdgeList`, such that two keys are
/// connected if an edge exists between them, and the `DirectedEdgeList`
/// resolves which edges actually exist.
///
/// \tparam Key
/// Key type.
///
/// \tparam Alloc
/// Allocator type.
///
template <typename Key, typename Alloc = std::allocator<std::byte>>
class AdjacencyLists {
  public:
    struct Link {
        Link* next = nullptr;
        Link* prev = nullptr;
        Key value;
    };

    typedef LinkList<Link*> List;

    typedef typename List::iterator ListIterator;

    typedef typename List::const_iterator ConstListIterator;

    using ListContainer = std::unordered_map<
            Key,
            List,
            std::hash<Key>,
            std::equal_to<Key>,
            typename std::allocator_traits<Alloc>::template rebind_alloc<
                    std::pair<const Key, List>>>;

    /// \name Container typedefs
    /** \{ */

    typedef typename ListContainer::size_type size_type;

    typedef typename ListContainer::difference_type difference_type;

    typedef typename ListContainer::value_type value_type;

    typedef typename ListContainer::reference reference;

    typedef typename ListContainer::const_reference const_reference;

    typedef typename ListContainer::iterator iterator;

    typedef typename ListContainer::const_iterator const_iterator;

    typedef Alloc allocator_type;

    /** \} */

  public:
    AdjacencyLists() = default;

    explicit AdjacencyLists(const Alloc& alloc)
        : link_pool_(0, alloc), lists_(0, alloc) {
    }

    AdjacencyLists(const AdjacencyLists& other, const Alloc& alloc = {})
        : link_pool_(0, alloc), lists_(0, alloc) {
        reserve(other.size());
        for (const auto& val : other)
            for (const auto& key : val.second)
                connect(val.first, key);
    }

    AdjacencyLists(AdjacencyLists&&) = default;

    AdjacencyLists(AdjacencyLists&& other, const Alloc& alloc = {})
        : link_pool_(std::move(other.link_pool_), alloc),
          lists_(std::move(other.lists_), alloc) {
    }

    AdjacencyLists& operator=(const AdjacencyLists& other) {
        if (this != &other) {
            clear();
            reserve(other.size());
            for (const auto& val : other)
                for (const auto& key : val.second)
                    connect(val.first, key);
        }
        return *this;
    }

    AdjacencyLists& operator=(AdjacencyLists&&) = default;

  public:
    /// \name Container API
    /** \{ */

    [[nodiscard]] bool empty() const noexcept {
        return lists_.empty();
    }

    size_type size() const noexcept {
        return lists_.size();
    }

    size_type max_size() const noexcept {
        return lists_.max_size();
    }

    void clear() noexcept {
        link_pool_.reset();
        lists_.clear();
    }

    void reserve(size_type count) {
        lists_.reserve(count);
    }

    iterator begin() noexcept {
        return lists_.begin();
    }

    const_iterator begin() const noexcept {
        return lists_.begin();
    }

    const_iterator cbegin() const noexcept {
        return begin(); // Force const
    }

    iterator end() noexcept {
        return lists_.end();
    }

    const_iterator end() const noexcept {
        return lists_.end();
    }

    const_iterator cend() const noexcept {
        return end(); // Force const
    }

    float load_factor() const {
        return lists_.load_factor();
    }

    float max_load_factor() const {
        return lists_.max_load_factor();
    }

    void max_load_factor(float factor) {
        lists_.max_load_factor(factor);
    }

    void swap(AdjacencyLists& other) {
        if (this != &other) {
            link_pool_.swap(other.link_pool_);
            lists_.swap(other.lists_);
        }
    }

    allocator_type get_allocator() const noexcept {
        return lists_.get_allocator();
    }

    /** \} */

  public:
    /// \name Connectivity
    /** \{ */

    /// Connect.
    void connect(const Key& key0, const Key& key1) {
        list_add_(lists_[key0], key1);
        list_add_(lists_[key1], key0);
    }

    /// Connect one to many.
    void connect(const Key& key0, std::initializer_list<const Key> keys) {
        for (const Key& key1 : keys)
            connect(key0, key1);
    }

    /// Disconnect.
    void disconnect(const Key& key0, const Key& key1) {
        auto list_pos0 = lists_.find(key0);
        if (list_pos0 != lists_.end()) {
            list_remove_(list_pos0->second, key1);
            if (list_pos0->second.empty())
                lists_.erase(list_pos0);
        }

        auto list_pos1 = lists_.find(key1);
        if (list_pos1 != lists_.end()) {
            list_remove_(list_pos1->second, key0);
            if (list_pos1->second.empty())
                lists_.erase(list_pos1);
        }
    }

    /// Disconnect from all.
    void disconnect(const Key& key) {
        auto list_pos = lists_.find(key);
        if (list_pos != lists_.end()) {
            auto* link = list_pos->second.head;
            while (link) {
                auto* next = link->next;
                // Only remove if not self-connection, in which
                // case removal would be redundant.
                if (link->value != key)
                    list_remove_(lists_.at(link->value), key);
                link_pool_.deallocate(link);
                link = next;
            }
            lists_.erase(list_pos);
        }
    }

    /// Erase.
    ListIterator erase(const Key& key, ConstListIterator pos) {
        auto* link = const_cast<Link*>(pos.link);
        auto* next = link->next;
        disconnect(key, *pos);
        return {next};
    }

    /// Iterator range over adjacent keys.
    IteratorRange<ListIterator> operator[](const Key& key) {
        if (auto list_pos = lists_.find(key); list_pos != lists_.end())
            return {list_pos->second.begin(), list_pos->second.end()};
        else
            return {};
    }

    /// Iterator range over adjacent keys, const variant.
    IteratorRange<ConstListIterator> operator[](const Key& key) const {
        if (auto list_pos = lists_.find(key); list_pos != lists_.end())
            return {list_pos->second.begin(), list_pos->second.end()};
        else
            return {};
    }

    /** \} */

  private:
    ObjectMemoryPool<Link, Alloc> link_pool_;

    ListContainer lists_;

  private:
    void list_add_(List& list, const Key& key) {
        if (list.contains(key) == false) {
            Link* link = static_cast<Link*>(link_pool_.allocate());
            link->next = nullptr;
            link->prev = nullptr;
            link->value = key;
            list.prepend(link);
        }
    }

    void list_remove_(List& list, const Key& key) {
        link_pool_.deallocate(
                list.remove(std::find(list.begin(), list.end(), key)));
    }
};

/// An edge list.
///
/// This structure represents graph connectivity information as a
/// list of edges, where each edge is associated with the data stored
/// by type `Edge`. The edge list is not really a list, but rather a
/// hash table represented by `std::unordered_map` which maps pairs of
/// `NodeKey` keys to `Edge` edges. As such, edge lookup happens in
/// constant time on average.
///
/// This structure may represent directed or undirected connectivity
/// information, using the template flag `IsDirected`. If directed,
/// then the order of the node keys in a node pair matters. If undirected,
/// then the order does not matter.
///
/// \tparam IsDirected
/// Is directed?
///
/// \tparam Adjacency
/// Include adjacency lists representation?
///
/// \tparam NodeKey
/// Node key type. In practice, this should be an integer
/// identifier, or a pointer or iterator to an externally managed
/// node object.
///
/// \tparam Edge
/// Edge type.
///
/// \tparam Alloc
/// Allocator type.
///
template <
        bool IsDirected,
        bool Adjacency,
        typename NodeKey,
        typename Edge,
        typename Alloc = std::allocator<std::byte>>
class EdgeList {
  public:
    typedef std::pair<NodeKey, NodeKey> EdgeKey;

    struct EdgeKeyHash {
        std::size_t operator()(EdgeKey key) const {
            if constexpr (!IsDirected)
                if (!(key.first < key.second))
                    std::swap(key.first, key.second);
            std::size_t hash0 = std::hash<NodeKey>()(key.first);
            std::size_t hash1 = std::hash<NodeKey>()(key.second);
            return hash0 ^ (hash1 << 1);
        }
    };

    struct EdgeKeyEqual {
        bool operator()(EdgeKey lhs, EdgeKey rhs) const {
            if constexpr (!IsDirected) {
                if (!(lhs.first < lhs.second))
                    std::swap(lhs.first, lhs.second);
                if (!(rhs.first < rhs.second))
                    std::swap(rhs.first, rhs.second);
            }
            return lhs == rhs;
        }
    };

    using EdgeContainer = std::unordered_map<
            EdgeKey,
            Edge,
            EdgeKeyHash,
            EdgeKeyEqual,
            typename std::allocator_traits<Alloc>::template rebind_alloc<
                    std::pair<const EdgeKey, Edge>>>;

    /// \name Container typedefs
    /** \{ */

    typedef typename EdgeContainer::size_type size_type;

    typedef typename EdgeContainer::difference_type difference_type;

    typedef typename EdgeContainer::value_type value_type;

    typedef typename EdgeContainer::reference reference;

    typedef typename EdgeContainer::const_reference const_reference;

    typedef typename EdgeContainer::iterator iterator;

    typedef typename EdgeContainer::const_iterator const_iterator;

    typedef Alloc allocator_type;

    /** \} */

    using Lists = std::conditional_t<
            Adjacency,
            AdjacencyLists<NodeKey, Alloc>,
            std::monostate>;

  public:
    EdgeList() = default;

    EdgeList(const EdgeList&) = default;

    EdgeList(const EdgeList& other, const Alloc& alloc)
        : edges_(other.edges_, alloc) {
        if constexpr (Adjacency)
            new (&lists_) Lists(other.lists_, alloc);
    }

    EdgeList(EdgeList&&) = default;

    EdgeList(EdgeList&& other, const Alloc& alloc)
        : edges_(std::move(other.edges_), alloc) {
        if constexpr (Adjacency)
            new (&lists_) Lists(std::move(other.lists_), alloc);
    }

    explicit EdgeList(const Alloc& alloc) : edges_(alloc) {
    }

    template <std::input_iterator Iterator, typename... Args>
    EdgeList(Iterator first, Iterator last, Args&&... args)
        : edges_(first, last, std::forward<Args>(args)...) {
        if constexpr (Adjacency)
            for (const auto& val : edges_)
                lists_.connect(val.first.first, val.first.second);
    }

    EdgeList& operator=(const EdgeList&) = default;

    EdgeList& operator=(EdgeList&&) = default;

  public:
    /// \name Container API
    /** \{ */

    [[nodiscard]] bool empty() const noexcept {
        return edges_.empty();
    }

    size_type size() const noexcept {
        return edges_.size();
    }

    size_type max_size() const noexcept {
        return edges_.max_size();
    }

    void clear() noexcept {
        edges_.clear();
        if constexpr (Adjacency)
            lists_.clear();
    }

    void reserve(size_type count) {
        edges_.reserve(count);
        if constexpr (Adjacency)
            lists_.reserve(count);
    }

    iterator begin() noexcept {
        return edges_.begin();
    }

    const_iterator begin() const noexcept {
        return edges_.begin();
    }

    const_iterator cbegin() const noexcept {
        return begin(); // Force const
    }

    iterator end() noexcept {
        return edges_.end();
    }

    const_iterator end() const noexcept {
        return edges_.end();
    }

    const_iterator cend() const noexcept {
        return end(); // Force const
    }

    iterator find(const EdgeKey& key) {
        return edges_.find(key);
    }

    const_iterator find(const EdgeKey& key) const {
        return edges_.find(key);
    }

    bool contains(const EdgeKey& key) const {
        return edges_.contains(key);
    }

    bool contains(const NodeKey& key0, const NodeKey& key1) const {
        return edges_.contains(EdgeKey(key0, key1));
    }

    std::pair<iterator, bool> insert(const value_type& value) {
        auto result = edges_.insert(value);
        if constexpr (Adjacency)
            if (result.second)
                lists_.connect(value.first.first, value.first.second);
        return result;
    }

    iterator erase(const_iterator pos) {
        if constexpr (Adjacency) {
            const EdgeKey& key = pos->first;
            if (!IsDirected || !edges_.contains({key.second, key.first})) {
                lists_.disconnect(key.first, key.second);
            }
        }
        return edges_.erase(pos);
    }

    iterator erase(const_iterator pos0, const_iterator pos1) {
        if constexpr (Adjacency) {
            while (pos0 != pos1)
                pos0 = erase(pos0);
        }
        else {
            return edges_.erase(pos0, pos1);
        }
    }

    Edge& operator[](const EdgeKey& key) {
        if constexpr (Adjacency) {
            auto [edge_pos, inserted] = edges_.insert({key, {}});
            if (inserted)
                lists_.connect(key.first, key.second);
            return edge_pos->second;
        }
        else {
            return edges_[key];
        }
    }

    Edge& operator()(const NodeKey& key0, const NodeKey& key1) {
        return operator[](EdgeKey(key0, key1));
    }

    Edge& at(const EdgeKey& key) {
        return edges_.at(key);
    }

    Edge& at(const NodeKey& key0, const NodeKey& key1) {
        return edges_.at({key0, key1});
    }

    const Edge& at(const EdgeKey& key) const {
        return edges_.at(key);
    }

    const Edge& at(const NodeKey& key0, const NodeKey& key1) const {
        return edges_.at({key0, key1});
    }

    float load_factor() const {
        return edges_.load_factor();
    }

    float max_load_factor() const {
        return edges_.max_load_factor();
    }

    void max_load_factor(float factor) {
        edges_.max_load_factor(factor);
    }

    void swap(EdgeList& other) {
        if (this != &other) {
            edges_.swap(other.edges_);
            if constexpr (Adjacency)
                lists_.swap(other.lists_);
        }
    }

    allocator_type get_allocator() const noexcept {
        return edges_.get_allocator();
    }

    /** \} */

  public:
    /// \name Connectivity
    /** \{ */

    auto operator[](const NodeKey& key) requires Adjacency {
        return lists_[key];
    }

    auto operator[](const NodeKey& key) const requires Adjacency {
        return lists_[key];
    }

    void disconnect(const NodeKey& key0) requires Adjacency {
        for (const NodeKey& key1 : lists_[key0]) {
            if constexpr (IsDirected) {
                if (auto pos = edges_.find({key0, key1}); pos != edges_.end())
                    edges_.erase(pos);
                if (auto pos = edges_.find({key1, key0}); pos != edges_.end())
                    edges_.erase(pos);
            }
            else {
                edges_.erase(edges_.find({key0, key1}));
            }
        }
        lists_.disconnect(key0);
    }

    /** \} */

  private:
    /// Edges.
    EdgeContainer edges_;

    /// Adjacency lists (maybe).
    Lists lists_;
};

template <
        typename NodeKey,
        typename Edge,
        typename Alloc = std::allocator<std::byte>>
using UndirectedEdgeList = EdgeList<false, false, NodeKey, Edge, Alloc>;

template <
        typename NodeKey,
        typename Edge,
        typename Alloc = std::allocator<std::byte>>
using UndirectedEdgeListWithAdjacency =
        EdgeList<false, true, NodeKey, Edge, Alloc>;

template <
        typename NodeKey,
        typename Edge,
        typename Alloc = std::allocator<std::byte>>
using DirectedEdgeList = EdgeList<true, false, NodeKey, Edge, Alloc>;

template <
        typename NodeKey,
        typename Edge,
        typename Alloc = std::allocator<std::byte>>
using DirectedEdgeListWithAdjacency =
        EdgeList<true, true, NodeKey, Edge, Alloc>;

} // namespace pre

#endif // #ifndef PRE_DATA_STRUCTURES_ADJACENCY_LISTS
