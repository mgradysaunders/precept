/*-*- C++ -*-*/
/* Copyright (c) 2018-20 M. Grady Saunders
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *   1. Redistributions of source code must retain the above
 *      copyright notice, this list of conditions and the following
 *      disclaimer.
 *
 *   2. Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following
 *      disclaimer in the documentation and/or other materials
 *      provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/*-*-*-*-*-*-*/
#if !(__cplusplus >= 201709L)
#error "Precept requires >= C++20"
#endif // #if !(__cplusplus >= 201709L)
#pragma once
#ifndef PRE_MEMORY_MEM_ARENA
#define PRE_MEMORY_MEM_ARENA

// for size_t, std::ptrdiff_t
#include <cstddef>

// for std::allocator, std::shared_ptr
#include <memory>

// for operator new, operator delete, ...
#include <new>

// for std::vector
#include <vector>

// for std::move
#include <utility>

// for std::logic_error, std::invalid_argument, ...
#include <stdexcept>

// for std::true_type, std::false_type, ...
#include <type_traits>

namespace pre {

/// A memory arena.
template <typename Alloc = std::allocator<std::byte>>
class MemArena {
  public:
    typedef Alloc allocator_type;

    typedef std::allocator_traits<Alloc> allocator_traits;

    MemArena(size_t block_size = 0, const Alloc& alloc = Alloc()) noexcept
        : block_size_(block_size), free_blocks_(alloc), full_blocks_(alloc),
          alloc_(alloc) {
        // Round up to 256 byte interval.
        block_size_ += 255u;
        block_size_ &= ~255u;
        if (block_size_ == 0)
            block_size_ = 65536;
        // Allocate initial block, reserve blocks.
        block_.size = block_size_;
        block_.begin = alloc_.allocate(block_.size);
        block_.offset = 0;
        free_blocks_.reserve(4);
        full_blocks_.reserve(4);
    }

    MemArena(const MemArena&) = delete;

    MemArena(MemArena&& other) noexcept
        : block_size_(std::exchange(other.block_size_, 0)),
          block_(std::exchange(other.block_, Block{})),
          free_blocks_(std::move(other.free_blocks_)),
          full_blocks_(std::move(other.full_blocks_)),
          alloc_(std::move(other.alloc_)) {
    }

    MemArena(MemArena&& other, const Alloc& alloc)
        : block_size_(std::exchange(other.block_size_, 0)),
          block_(std::exchange(other.block_, Block{})),
          free_blocks_(std::move(other.free_blocks_)),
          full_blocks_(std::move(other.full_blocks_)), alloc_(alloc) {
        // We need to be able to deallocate the pointers we stole!
        if (alloc_ != other.alloc)
            throw std::invalid_argument(__func__);
    }

    ~MemArena() {
        alloc_.deallocate(block_.begin, block_.size);
        for (Block& block : free_blocks_)
            alloc_.deallocate(block.begin, block.size);
        for (Block& block : full_blocks_)
            alloc_.deallocate(block.begin, block.size);
    }

    MemArena& operator=(const MemArena&) = delete;

    MemArena& operator=(MemArena&& other) noexcept {
        block_size_ = std::exchange(other.block_size_, 0);
        block_ = std::exchange(other.block_, Block{});
        free_blocks_ = std::move(other.free_blocks_);
        full_blocks_ = std::move(other.full_blocks_);
        if constexpr (allocator_traits::
                              propagate_on_container_move_assignment::value)
            alloc_ = std::move(other.alloc_);
        return *this;
    }

  public:
    /// Allocate bytes.
    void* allocate(size_t size) {
        // Round up to 16 byte interval.
        size += 15u;
        size &= ~15u;
        if (size == 0)
            return nullptr;

        if (block_.size < block_.offset + size) {
            full_blocks_.emplace_back(block_);
            if (free_blocks_.size() == 0 || free_blocks_.back().size < size) {
                // Allocate block.
                block_.size = std::max(block_size_, size);
                block_.begin = alloc_.allocate(block_.size);
                block_.offset = 0;
            }
            else {
                // Use free block.
                block_ = free_blocks_.back();
                free_blocks_.pop_back();
            }
        }
        std::byte* pos = block_.begin + block_.offset;
        block_.offset += size;
        return static_cast<void*>(pos);
    }

    /// Allocate given type.
    template <typename T>
    T* allocate(size_t count = 1) {
        return static_cast<T*>(allocate(sizeof(T) * count));
    }

    /// Clear.
    void clear() {
        // Clear current block.
        block_.offset = 0;
        // Convert full blocks to free blocks.
        free_blocks_.reserve(free_blocks_.size() + full_blocks_.size());
        for (Block& block : full_blocks_) {
            free_blocks_.push_back(block);
            free_blocks_.back().offset = 0;
        }
        full_blocks_.clear();
    }

    /// Clear and deallocate.
    void reset() {
        block_.offset = 0;
        for (Block& block : free_blocks_)
            alloc_.deallocate(block.begin, block.size);
        for (Block& block : full_blocks_)
            alloc_.deallocate(block.begin, block.size);
        free_blocks_.clear();
        full_blocks_.clear();
    }

    void swap(MemArena& other) {
        if (this != &other) {
            std::swap(block_size_, other.block_size_);
            std::swap(block_, other.block_);
            std::swap(free_blocks_, other.free_blocks_);
            std::swap(full_blocks_, other.full_blocks_);
            if constexpr (allocator_traits::propagate_on_container_swap::value)
                std::swap(alloc_, other.alloc_);
        }
    }

  private:
    /// A memory block.
    struct Block {
        std::byte* begin; /// Pointer to bytes.
        size_t offset;    ///< Offset.
        size_t size;      ///< Size.
    };

    size_t block_size_;

    Block block_;

    template <typename T>
    using RebindAlloc = typename allocator_traits::template rebind_alloc<T>;

    template <typename T>
    using RebindVector = std::vector<T, RebindAlloc<T>>;

    RebindVector<Block> free_blocks_;

    RebindVector<Block> full_blocks_;

    RebindAlloc<std::byte> alloc_;
};

/// A standard-compatible memory arena allocator.
template <typename T, typename Alloc = std::allocator<std::byte>>
class MemArenaAllocator {
  public:
    typedef T value_type;

    typedef std::true_type propagate_on_container_copy_assignment;

    typedef std::true_type propagate_on_container_move_assignment;

    typedef std::true_type propagate_on_container_swap;

    typedef std::false_type is_always_equal;

  public:
    MemArenaAllocator(size_t block_size = 0, const Alloc& alloc = Alloc())
        : arena_(new MemArena<Alloc>(block_size, alloc)) {
    }

    template <typename U>
    MemArenaAllocator(const MemArenaAllocator<U, Alloc>& other)
        : arena_(other.arena_) {
    }

    template <typename U>
    MemArenaAllocator(MemArenaAllocator<U, Alloc>&& other)
        : arena_(std::move(other.arena_)) {
    }

    template <typename U>
    MemArenaAllocator& operator=(const MemArenaAllocator<U, Alloc>& other) {
        if (this != &other) {
            this->arena_ = other.arena_;
        }
        return *this;
    }

    template <typename U>
    MemArenaAllocator& operator=(MemArenaAllocator<U, Alloc>&& other) {
        this->arena_ = std::move(other.arena_);
        return *this;
    }

    void clear() {
        arena_->clear();
    }

    void reset() {
        arena_->reset();
    }

    [[nodiscard]] T* allocate(size_t n) {
        return static_cast<T*>(arena_->allocate(sizeof(T) * n));
    }

    void deallocate(T*, size_t) {
    }

    template <typename U>
    bool operator==(const MemArenaAllocator<U, Alloc>& other) const {
        return arena_.get() == other.arena_.get();
    }

    template <typename U>
    bool operator!=(const MemArenaAllocator<U, Alloc>& other) const {
        return arena_.get() != other.arena_.get();
    }

  private:
    std::shared_ptr<MemArena<Alloc>> arena_;

    template <typename, typename>
    friend class MemArenaAllocator;
};

} // namespace pre

template <typename Alloc>
inline void* operator new(size_t size, pre::MemArena<Alloc>& mem_arena) {
    return mem_arena.allocate(size);
}

template <typename Alloc>
inline void* operator new[](size_t size, pre::MemArena<Alloc>& mem_arena) {
    return mem_arena.allocate(size);
}

template <typename Alloc>
inline void operator delete(void*, pre::MemArena<Alloc>&) noexcept {
}

template <typename Alloc>
inline void operator delete[](void*, pre::MemArena<Alloc>&) noexcept {
}

#endif // #ifndef PRE_MEMORY_MEM_ARENA
